{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"source/images/1.jpeg","path":"images/1.jpeg","modified":0,"renderable":0},{"_id":"source/me/index.html","path":"me/index.html","modified":0,"renderable":0},{"_id":"source/me/css/38240665.jpeg","path":"me/css/38240665.jpeg","modified":0,"renderable":0},{"_id":"source/me/css/animate.css","path":"me/css/animate.css","modified":0,"renderable":0},{"_id":"source/me/css/bootstrap.min.css","path":"me/css/bootstrap.min.css","modified":0,"renderable":0},{"_id":"source/me/css/font-awesome.min.css","path":"me/css/font-awesome.min.css","modified":0,"renderable":0},{"_id":"source/me/css/templatemo-style.css","path":"me/css/templatemo-style.css","modified":0,"renderable":0},{"_id":"source/me/fonts/FontAwesome.otf","path":"me/fonts/FontAwesome.otf","modified":0,"renderable":0},{"_id":"source/me/fonts/fontawesome-webfont.eot","path":"me/fonts/fontawesome-webfont.eot","modified":0,"renderable":0},{"_id":"source/me/fonts/fontawesome-webfont.svg","path":"me/fonts/fontawesome-webfont.svg","modified":0,"renderable":0},{"_id":"source/me/fonts/fontawesome-webfont.ttf","path":"me/fonts/fontawesome-webfont.ttf","modified":0,"renderable":0},{"_id":"source/me/fonts/fontawesome-webfont.woff","path":"me/fonts/fontawesome-webfont.woff","modified":0,"renderable":0},{"_id":"source/me/fonts/fontawesome-webfont.woff2","path":"me/fonts/fontawesome-webfont.woff2","modified":0,"renderable":0},{"_id":"source/me/images/1.jpg","path":"me/images/1.jpg","modified":0,"renderable":0},{"_id":"source/me/images/2.jpg","path":"me/images/2.jpg","modified":0,"renderable":0},{"_id":"source/me/images/3.jpg","path":"me/images/3.jpg","modified":0,"renderable":0},{"_id":"source/me/images/4.jpg","path":"me/images/4.jpg","modified":0,"renderable":0},{"_id":"source/me/images/5.jpg","path":"me/images/5.jpg","modified":0,"renderable":0},{"_id":"source/me/images/6.png","path":"me/images/6.png","modified":0,"renderable":0},{"_id":"source/me/images/7.png","path":"me/images/7.png","modified":0,"renderable":0},{"_id":"source/me/images/about-img.jpg","path":"me/images/about-img.jpg","modified":0,"renderable":0},{"_id":"source/me/images/contact-img.jpg","path":"me/images/contact-img.jpg","modified":0,"renderable":0},{"_id":"source/me/images/education-img.jpg","path":"me/images/education-img.jpg","modified":0,"renderable":0},{"_id":"source/me/images/experience-img.jpg","path":"me/images/experience-img.jpg","modified":0,"renderable":0},{"_id":"source/me/images/home-img.jpg","path":"me/images/home-img.jpg","modified":0,"renderable":0},{"_id":"source/me/images/quotes-bg.jpg","path":"me/images/quotes-bg.jpg","modified":0,"renderable":0},{"_id":"source/me/js/bootstrap.min.js","path":"me/js/bootstrap.min.js","modified":0,"renderable":0},{"_id":"source/me/js/custom.js","path":"me/js/custom.js","modified":0,"renderable":0},{"_id":"source/me/js/jquery.js","path":"me/js/jquery.js","modified":0,"renderable":0},{"_id":"source/me/js/jquery.parallax.js","path":"me/js/jquery.parallax.js","modified":0,"renderable":0},{"_id":"source/me/js/smoothscroll.js","path":"me/js/smoothscroll.js","modified":0,"renderable":0},{"_id":"source/me/js/wow.min.js","path":"me/js/wow.min.js","modified":0,"renderable":0}],"Cache":[{"_id":"source/_data/styles.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641995671459},{"_id":"source/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1636474528352},{"_id":"source/tags/index.md","hash":"d34e47fe2d6770d34b1db85e3f819ded6aabebe9","modified":1647436084299},{"_id":"source/categories/index.md","hash":"8c3edb56709ea6a9468184d66e9489445cec28ae","modified":1647436096635},{"_id":"source/_posts/php/202011131151.md","hash":"1ca1c67ca955de492c17400df395e3f03ff92959","modified":1647436616091},{"_id":"source/images/1.jpeg","hash":"da2a2db8f5b646b07f5e1b0de120865d3a48b910","modified":1531630693000},{"_id":"source/me/index.html","hash":"4e75e5251c62dffade9a99e54623965dd103ac4b","modified":1627015715536},{"_id":"source/_posts/sql/202011172350.md","hash":"0ce03591b8911029cc87dbdd3989d30998c7abbd","modified":1647436488747},{"_id":"source/_posts/sql/202012132016.md","hash":"0e74a06657db3f82a51f369b32746a50831be2a7","modified":1647436486678},{"_id":"source/.DS_Store","hash":"d8d51e4b263cb618c632def77833926eeb54bd16","modified":1636550274929},{"_id":"source/_posts/unit-test/202103061655.md","hash":"c4e0f11cea0a399dce9d7c37fdc0cb9cc6972aba","modified":1647436569163},{"_id":"source/_posts/sql/202101172100.md","hash":"df994917804a510af7a9b08de0a6d1749b79b9ae","modified":1647436485050},{"_id":"source/me/css/38240665.jpeg","hash":"da2a2db8f5b646b07f5e1b0de120865d3a48b910","modified":1613574575278},{"_id":"source/me/css/font-awesome.min.css","hash":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1613574575283},{"_id":"source/me/css/templatemo-style.css","hash":"95513666bde04cb5019f3c89bab2d9630575de73","modified":1613575940987},{"_id":"source/me/images/1.jpg","hash":"a30a9a6cffed272c3f8d151e2c1942a5a686ee01","modified":1613574575299},{"_id":"source/me/js/custom.js","hash":"046f400d551fd5bedd0f03d6dfa1a1729f4e1a76","modified":1613574575376},{"_id":"source/me/js/bootstrap.min.js","hash":"791aa054a026bddc0de92bad6cf7a1c6e73713d5","modified":1613574575373},{"_id":"source/me/js/smoothscroll.js","hash":"cec66b963de93a331e41d17413fe80ae944cde28","modified":1613574575386},{"_id":"source/me/js/wow.min.js","hash":"13895175fe8fc3bb341af017a197ce8599e59451","modified":1613574575389},{"_id":"source/me/js/jquery.parallax.js","hash":"8e6becfa131e38b0e1975264ee26534fba436b31","modified":1613574575383},{"_id":"source/_posts/feeling/202011121830.md","hash":"62c2b05a3432837eb9e2b841fec6b8c3b9e493c4","modified":1647436583769},{"_id":"source/me/css/animate.css","hash":"a7d6232134c76a27143ab60addcec0cdf5ee0e3f","modified":1613574575280},{"_id":"source/me/css/bootstrap.min.css","hash":"8eb176c70b9cfa6871b76d6dc98fb526e7e9b3de","modified":1613574575281},{"_id":"source/me/fonts/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1613574575287},{"_id":"source/me/fonts/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1613574575285},{"_id":"source/me/fonts/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1613574575296},{"_id":"source/me/fonts/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1613574575293},{"_id":"source/me/images/5.jpg","hash":"a7bf817355002bafa1f4b2dd0a6126d9b0947743","modified":1613574575329},{"_id":"source/me/js/jquery.js","hash":"d6c1f41972de07b09bfa63d2e50f9ab41ec372bd","modified":1613574575379},{"_id":"source/me/fonts/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1613574575292},{"_id":"source/me/images/2.jpg","hash":"c83ccfa2c055b04cf6c2f25f9c360cddc0234d4b","modified":1613574575300},{"_id":"source/me/images/7.png","hash":"2c14c7aa3ee9df59b077e26e6cdcc0212f6e1816","modified":1613574575336},{"_id":"source/me/images/about-img.jpg","hash":"e098285448ee8d3388fa0e0ae9977caa8ce2cc08","modified":1613574575338},{"_id":"source/me/images/education-img.jpg","hash":"d1b256e9a979e4940b0d56c4b1d33b4ce72b095d","modified":1613574575342},{"_id":"source/me/images/contact-img.jpg","hash":"0606ca8f5a57ff05189563fd8c47e55b97a1f929","modified":1613574575340},{"_id":"source/me/images/experience-img.jpg","hash":"34dd9bbe6edaba6f9a4841a06005c3b0287d5a6c","modified":1613574575344},{"_id":"source/me/images/quotes-bg.jpg","hash":"43bc383e328a1432518d10bf9c0d36730941d192","modified":1613574575365},{"_id":"source/me/images/home-img.jpg","hash":"2c9992080b972bf82a258572e7375e4bcccba687","modified":1613574575361},{"_id":"source/me/fonts/fontawesome-webfont.svg","hash":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1613574575289},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1647435452336},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1647435452337},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1647435452337},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1647435452343},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1647435452343},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1647435452343},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1647435452344},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1647435452344},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1647435452345},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1647435452355},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1647435452388},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1647435452338},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1647435452338},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1647435452340},{"_id":"themes/next/_config.yml","hash":"cd72072bdd41381fa25bf3fd60a03ede3ef2210f","modified":1648955547978},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1647435452341},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1647435452341},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1647435452341},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1647435452341},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1647435452342},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1647435452342},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1647435452342},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1647435452342},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1647435452347},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1647435452346},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1647435452347},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1647435452348},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1647435452348},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1647435452348},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1647435452349},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1647435452349},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1647435452349},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1647435452355},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1647435452355},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1647435452356},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1647435452356},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1647435452356},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1647435452356},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1647435452357},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1647435452357},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1647435452357},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1647435452358},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1647435452358},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1647435452358},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1647435452359},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1647435452359},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1647435452359},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1647435452360},{"_id":"themes/next/languages/tr.yml","hash":"2b041eeb8bd096f549464f191cfc1ea0181daca4","modified":1647435452360},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1647435452360},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1647435452361},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1647435452361},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1647435452362},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1647435452362},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1647435452362},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1647435452386},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1647435452387},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1647435452387},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1647435452387},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1647435452387},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1647435452388},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1647435452395},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1647435452339},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1647435452339},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1647435452340},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1647435452340},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1647435452350},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1647435452350},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1647435452351},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1647435452350},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1647435452352},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1647435452352},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1647435452351},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1647435452353},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1647435452353},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1647435452353},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1647435452354},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1647435452354},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1647435452355},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1647435452363},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1647435452363},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1647435452364},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1647435452365},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1647435452364},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1647435452367},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1647435452369},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1647435452373},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1647435452373},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1647435452373},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1647435452374},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1647435452376},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1647435452376},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1647435452378},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1647435452381},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1647435452382},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1647435452382},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1647435452389},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1647435452392},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1647435452393},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1647435452393},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1647435452394},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1647435452393},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1647435452394},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1647435452395},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1647435452394},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1647435452395},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1647435452396},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1647435452396},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1647435452396},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1647435452397},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1647435452397},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1647435452398},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1647435452397},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1647435452398},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1647435452398},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1647435452399},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1647435452429},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1647435452400},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1647435452436},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1647435452437},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1647435452437},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1647435452437},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1647435452439},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1647435452439},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1647435452438},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1647435452439},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1647435452440},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1647435452440},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1647435452440},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1647435452441},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1647435452441},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1647435452441},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1647435452442},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1647435452442},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1647435452442},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1647435452443},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1647435452442},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1647435452444},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1647435452444},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1647435452366},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1647435452365},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1647435452366},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1647435452366},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1647435452367},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1647435452367},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1647435452367},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1647435452368},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1647435452368},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1647435452369},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1647435452369},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1647435452370},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1647435452370},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1647435452370},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1647435452371},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1647435452371},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1647435452371},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1647435452372},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1647435452374},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1647435452375},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1647435452375},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1647435452375},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1647435452376},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1647435452377},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1647435452377},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1647435452377},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1647435452378},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1647435452378},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1647435452378},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1647435452379},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1647435452379},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1647435452380},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1647435452380},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1647435452380},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1647435452380},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1647435452383},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1647435452383},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1647435452383},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1647435452381},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1647435452381},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1647435452382},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1647435452384},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1647435452384},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1647435452385},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1647435452385},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1647435452385},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1647435452389},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1647435452389},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1647435452390},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1647435452386},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1647435452386},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1647435452390},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1647435452391},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1647435452391},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1647435452391},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1647435452391},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1647435452392},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1647435452392},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1647435452392},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1647435452434},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1647435452435},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1647435452435},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1647435452435},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1647435452436},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1647435452443},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1647435452443},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1647435452448},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1647435452449},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1647435452401},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1647435452401},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1647435452401},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1647435452412},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1647435452419},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1647435452419},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1647435452423},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1647435452423},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1647435452423},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1647435452425},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1647435452425},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1647435452425},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1647435452426},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1647435452428},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1647435452429},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1647435452430},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1647435452430},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1647435452430},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1647435452431},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1647435452431},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1647435452431},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1647435452431},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1647435452432},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1647435452432},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1647435452432},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1647435452433},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1647435452433},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1647435452433},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1647435452433},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1647435452434},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1647435452434},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1647435452434},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1647435452445},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1647435452447},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1647435452412},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1647435452413},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1647435452413},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1647435452414},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1647435452414},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1647435452407},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1647435452407},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1647435452408},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1647435452408},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1647435452408},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1647435452409},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1647435452409},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1647435452410},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1647435452410},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1647435452410},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1647435452411},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1647435452411},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1647435452412},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1647435452415},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1647435452419},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1647435452420},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1647435452420},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1647435452420},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1647435452420},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1647435452421},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1647435452421},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1647435452421},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1647435452422},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1647435452422},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1647435452415},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1647435452415},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1647435452416},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1647435452416},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1647435452417},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1647435452417},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1647435452418},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1647435452424},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1647435452424},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1647435452424},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1647435452424},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1647435452426},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1647435452427},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1647435452427},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1647435452427},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1647435452428},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1647435452428},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1647435452428},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1647435452403},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1647435452404},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1647435452405},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1647435452405},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1647435452406},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1647435452446},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1647435452447},{"_id":"source/me/images/6.png","hash":"b0c5bb05e213b7ba5b797992426ee856044abc9f","modified":1613574575333},{"_id":"source/me/images/3.jpg","hash":"3e3381a52aeaa4a3849ed029bf24dd4ba9ba25b8","modified":1613574575307},{"_id":"source/me/images/4.jpg","hash":"87f8bf05d90ed5917ff84952037f7663b8c317a6","modified":1613574575323},{"_id":"public/search.xml","hash":"9d6c58aa89efa4558e89db44f7d34e712d2e4516","modified":1647436811691},{"_id":"public/about/index.html","hash":"9b7902f05b1b30a3be355ae5d5d3f6a9e73b7daa","modified":1647436811691},{"_id":"public/categories/index.html","hash":"198e81ca1d419b879b477360bf9b5d5240f04fe6","modified":1647436811691},{"_id":"public/tags/index.html","hash":"94d4476342c660d6263dd4beb59675f9054725d2","modified":1647436811691},{"_id":"public/2021/03/06/unit-test/202103061655/index.html","hash":"cbe2acf3ef8e3d12b3c0f97f6e4a127af616230b","modified":1647436811691},{"_id":"public/2021/01/17/sql/202101172100/index.html","hash":"38db2cd8ff9038d3334da99a2e68985a42aebd97","modified":1647436811691},{"_id":"public/2020/12/23/sql/202012132016/index.html","hash":"2cd8483206df5354ee11fd441a62dc821fac51cb","modified":1647436811691},{"_id":"public/2020/11/17/sql/202011172350/index.html","hash":"4172d2af9963bab825e3c7d8ee19e49ac2d11818","modified":1647436811691},{"_id":"public/2020/11/15/php/202011131151/index.html","hash":"dffc8cb1ad39e9e348aaf1e95a3418dc79d1c235","modified":1647436811691},{"_id":"public/2020/11/10/feeling/202011121830/index.html","hash":"06c9a32a4468627ae227d594a667c7bc00bedd12","modified":1647436811691},{"_id":"public/archives/index.html","hash":"e032ef0053db5af9188868178eb1ea1bc2cef676","modified":1647436811691},{"_id":"public/archives/2020/index.html","hash":"3d2166fe89c853fb564888b65048e01322f730f3","modified":1647436811691},{"_id":"public/archives/2020/11/index.html","hash":"72f6c4a4910c90c8af081f2b76fd99d76f880419","modified":1647436811691},{"_id":"public/archives/2020/12/index.html","hash":"987158ee09e127004ce6c73753e041f1d84dc0c0","modified":1647436811691},{"_id":"public/archives/2021/index.html","hash":"605a931db65a6bcfa6ab7bb97aedfd08a327a83b","modified":1647436811691},{"_id":"public/archives/2021/01/index.html","hash":"6dc9dce3258e187219841b411dce6954be9ca3a7","modified":1647436811691},{"_id":"public/archives/2021/03/index.html","hash":"aa45994d41b878d996f29d0a3731f4731513d1f8","modified":1647436811691},{"_id":"public/categories/php/index.html","hash":"79e5c6163f3c63fa3d294a8a7db2945b80246013","modified":1647436811691},{"_id":"public/categories/資料庫/index.html","hash":"19c50d392e3d2f78f23efc1fde3b5addfc8b3295","modified":1647436811691},{"_id":"public/categories/單元測試/index.html","hash":"02eea9fc2dd000daf3aa36f6e6a851ad13cba7d0","modified":1647436811691},{"_id":"public/categories/心情日誌/index.html","hash":"50d29c667a5c52a05fe49fd9c3315541cde08b3b","modified":1647436811691},{"_id":"public/index.html","hash":"3d59923309480a7d51402e618f0649c7063af4f2","modified":1647436811691},{"_id":"public/tags/php/index.html","hash":"9f2b8f0ba4f94ebeda54cb20cc2fc79682de349f","modified":1647436811691},{"_id":"public/tags/資料庫/index.html","hash":"b162bc87c5ee5442420f4e37cae80e6e105b67f0","modified":1647436811691},{"_id":"public/tags/單元測試/index.html","hash":"5a5e8ba243810ce485ed1f5f2c32d407fe9fd535","modified":1647436811691},{"_id":"public/tags/心情日誌/index.html","hash":"5a9d08ab7fa1ae95f1088bd1809a4518cafdd195","modified":1647436811691},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1647436811691},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1647436811691},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1647436811691},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1647436811691},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1647436811691},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1647436811691},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1647436811691},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1647436811691},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1647436811691},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1647436811691},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1647436811691},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1647436811691},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1647436811691},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1647436811691},{"_id":"public/images/1.jpeg","hash":"da2a2db8f5b646b07f5e1b0de120865d3a48b910","modified":1647436811691},{"_id":"public/me/index.html","hash":"4e75e5251c62dffade9a99e54623965dd103ac4b","modified":1647436811691},{"_id":"public/me/css/38240665.jpeg","hash":"da2a2db8f5b646b07f5e1b0de120865d3a48b910","modified":1647436811691},{"_id":"public/me/css/font-awesome.min.css","hash":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1647436811691},{"_id":"public/me/css/templatemo-style.css","hash":"95513666bde04cb5019f3c89bab2d9630575de73","modified":1647436811691},{"_id":"public/me/images/1.jpg","hash":"a30a9a6cffed272c3f8d151e2c1942a5a686ee01","modified":1647436811691},{"_id":"public/me/js/custom.js","hash":"046f400d551fd5bedd0f03d6dfa1a1729f4e1a76","modified":1647436811691},{"_id":"public/me/js/bootstrap.min.js","hash":"791aa054a026bddc0de92bad6cf7a1c6e73713d5","modified":1647436811691},{"_id":"public/me/js/jquery.parallax.js","hash":"8e6becfa131e38b0e1975264ee26534fba436b31","modified":1647436811691},{"_id":"public/me/js/smoothscroll.js","hash":"cec66b963de93a331e41d17413fe80ae944cde28","modified":1647436811691},{"_id":"public/me/js/wow.min.js","hash":"13895175fe8fc3bb341af017a197ce8599e59451","modified":1647436811691},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1647436811691},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1647436811691},{"_id":"public/me/css/animate.css","hash":"a7d6232134c76a27143ab60addcec0cdf5ee0e3f","modified":1647436811691},{"_id":"public/me/css/bootstrap.min.css","hash":"8eb176c70b9cfa6871b76d6dc98fb526e7e9b3de","modified":1647436811691},{"_id":"public/me/fonts/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1647436811691},{"_id":"public/me/fonts/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1647436811691},{"_id":"public/me/fonts/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1647436811691},{"_id":"public/me/fonts/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1647436811691},{"_id":"public/me/images/5.jpg","hash":"a7bf817355002bafa1f4b2dd0a6126d9b0947743","modified":1647436811691},{"_id":"public/me/js/jquery.js","hash":"d6c1f41972de07b09bfa63d2e50f9ab41ec372bd","modified":1647436811691},{"_id":"public/me/fonts/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1647436811691},{"_id":"public/me/images/contact-img.jpg","hash":"0606ca8f5a57ff05189563fd8c47e55b97a1f929","modified":1647436811691},{"_id":"public/css/main.css","hash":"0cc91b629acb17b7ad9f50d809af87e6e845676c","modified":1647436811691},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1647436811691},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1647436811691},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1647436811691},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1647436811691},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1647436811691},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1647436811691},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1647436811691},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1647436811691},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1647436811691},{"_id":"public/me/images/2.jpg","hash":"c83ccfa2c055b04cf6c2f25f9c360cddc0234d4b","modified":1647436811691},{"_id":"public/me/images/7.png","hash":"2c14c7aa3ee9df59b077e26e6cdcc0212f6e1816","modified":1647436811691},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1647436811691},{"_id":"public/me/images/about-img.jpg","hash":"e098285448ee8d3388fa0e0ae9977caa8ce2cc08","modified":1647436811691},{"_id":"public/me/images/experience-img.jpg","hash":"34dd9bbe6edaba6f9a4841a06005c3b0287d5a6c","modified":1647436811691},{"_id":"public/me/images/quotes-bg.jpg","hash":"43bc383e328a1432518d10bf9c0d36730941d192","modified":1647436811691},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1647436811691},{"_id":"public/me/images/education-img.jpg","hash":"d1b256e9a979e4940b0d56c4b1d33b4ce72b095d","modified":1647436811691},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1647436811691},{"_id":"public/me/images/home-img.jpg","hash":"2c9992080b972bf82a258572e7375e4bcccba687","modified":1647436811691},{"_id":"public/me/fonts/fontawesome-webfont.svg","hash":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1647436811691},{"_id":"public/me/images/6.png","hash":"b0c5bb05e213b7ba5b797992426ee856044abc9f","modified":1647436811691},{"_id":"public/me/images/3.jpg","hash":"3e3381a52aeaa4a3849ed029bf24dd4ba9ba25b8","modified":1647436811691},{"_id":"public/me/images/4.jpg","hash":"87f8bf05d90ed5917ff84952037f7663b8c317a6","modified":1647436811691}],"Category":[{"name":"php","_id":"cl0tlcc650005fx7rfl319u0g"},{"name":"資料庫","_id":"cl0tlcc6b000afx7r54y5bre3"},{"name":"單元測試","_id":"cl0tlcc6j000mfx7r51gj9ip9"},{"name":"心情日誌","_id":"cl0tlcc6k000rfx7r7ebo99gn"}],"Data":[{"_id":"styles","data":""}],"Page":[{"_content":"","source":"about/index.html","raw":"","date":"2022-02-01T07:57:35.810Z","updated":"2021-11-09T16:15:28.352Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"cl0tlcc5m0000fx7r7gb14yfn","content":"","site":{"data":{"styles":""}},"excerpt":"","more":""},{"title":"categories","date":"2020-11-13T06:07:43.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-11-13 14:07:43\ntype: \"categories\"\ncomments: false\n---\n","updated":"2022-03-16T13:08:16.635Z","path":"categories/index.html","layout":"page","_id":"cl0tlcc5x0001fx7r4btdhqh2","content":"","site":{"data":{"styles":""}},"excerpt":"","more":""},{"title":"tags","date":"2021-11-10T13:38:41.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-11-10 21:38:41\ntype: \"tags\"\ncomments: false\n---\n","updated":"2022-03-16T13:08:04.299Z","path":"tags/index.html","layout":"page","_id":"cl0tlcc620003fx7r9p7b25rb","content":"","site":{"data":{"styles":""}},"excerpt":"","more":""}],"Post":[{"title":"PHP 簡單寫法","date":"2020-11-15T15:50:49.000Z","type":"tags","_content":"\n#### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;使用PHP語言時是不是覺得code的語法很簡單或是方便，比期編譯語言程式碼如JAVA、C#、C等個要來得簡單，但是隨著需求功能增加code份量就會增加，這時候就是朝向clean code方面去開發，但本章節不是探討clean code的而是**程式碼簡單寫法**。\n\n#### 何謂簡單寫法\n\n&nbsp;&nbsp;&nbsp;&nbsp;簡單寫法是一段程式碼從複雜到簡單，舉例來說條件式判斷常常占用到3行以上，下面這段條件式判斷，其實可以簡易條件式方式來縮短程式碼，來達到簡單程式碼。\n```\n    // 複雜\n    $food = \"漢堡\";\n    $eat = \"\";\n\n    if($food == \"漢堡\")\n    {\n        $eat = \"開動\";\n    }\n\n    // 簡單\n    $food = \"漢堡\";\n    $eat = ($food == \"漢堡\" ? \"開動\" : \"\");\n```\n&nbsp;&nbsp;&nbsp;&nbsp;而如果是畫面上印出資料時需要透過echo or print，其實可以透過更簡短方式<?=$xxx; ?>直接印出來。\n```\n   $str = \"Hello Word\";\n\n   //複雜\n   <?php echo $str; ?>\n\n   //簡單\n   <?=$str; ?>\n```\n&nbsp;&nbsp;&nbsp;&nbsp;小結:其實簡單寫法是為了讓複雜程式碼更簡單更好閱讀，雖說沒有一定準則但是能讓程式碼更短不是好嗎。","source":"_posts/php/202011131151.md","raw":"---\ntitle: PHP 簡單寫法\ndate: 2020-11-15 23:50:49\ntype: \"tags\"\ncategories: php\ntags: php\n---\n\n#### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;使用PHP語言時是不是覺得code的語法很簡單或是方便，比期編譯語言程式碼如JAVA、C#、C等個要來得簡單，但是隨著需求功能增加code份量就會增加，這時候就是朝向clean code方面去開發，但本章節不是探討clean code的而是**程式碼簡單寫法**。\n\n#### 何謂簡單寫法\n\n&nbsp;&nbsp;&nbsp;&nbsp;簡單寫法是一段程式碼從複雜到簡單，舉例來說條件式判斷常常占用到3行以上，下面這段條件式判斷，其實可以簡易條件式方式來縮短程式碼，來達到簡單程式碼。\n```\n    // 複雜\n    $food = \"漢堡\";\n    $eat = \"\";\n\n    if($food == \"漢堡\")\n    {\n        $eat = \"開動\";\n    }\n\n    // 簡單\n    $food = \"漢堡\";\n    $eat = ($food == \"漢堡\" ? \"開動\" : \"\");\n```\n&nbsp;&nbsp;&nbsp;&nbsp;而如果是畫面上印出資料時需要透過echo or print，其實可以透過更簡短方式<?=$xxx; ?>直接印出來。\n```\n   $str = \"Hello Word\";\n\n   //複雜\n   <?php echo $str; ?>\n\n   //簡單\n   <?=$str; ?>\n```\n&nbsp;&nbsp;&nbsp;&nbsp;小結:其實簡單寫法是為了讓複雜程式碼更簡單更好閱讀，雖說沒有一定準則但是能讓程式碼更短不是好嗎。","slug":"php/202011131151","published":1,"updated":"2022-03-16T13:16:56.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0tlcc5y0002fx7r3862h0pq","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;使用PHP語言時是不是覺得code的語法很簡單或是方便，比期編譯語言程式碼如JAVA、C#、C等個要來得簡單，但是隨著需求功能增加code份量就會增加，這時候就是朝向clean code方面去開發，但本章節不是探討clean code的而是<strong>程式碼簡單寫法</strong>。</p>\n<h4 id=\"何謂簡單寫法\"><a href=\"#何謂簡單寫法\" class=\"headerlink\" title=\"何謂簡單寫法\"></a>何謂簡單寫法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;簡單寫法是一段程式碼從複雜到簡單，舉例來說條件式判斷常常占用到3行以上，下面這段條件式判斷，其實可以簡易條件式方式來縮短程式碼，來達到簡單程式碼。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 複雜</span><br><span class=\"line\">$food &#x3D; &quot;漢堡&quot;;</span><br><span class=\"line\">$eat &#x3D; &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">if($food &#x3D;&#x3D; &quot;漢堡&quot;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $eat &#x3D; &quot;開動&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 簡單</span><br><span class=\"line\">$food &#x3D; &quot;漢堡&quot;;</span><br><span class=\"line\">$eat &#x3D; ($food &#x3D;&#x3D; &quot;漢堡&quot; ? &quot;開動&quot; : &quot;&quot;);</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;而如果是畫面上印出資料時需要透過echo or print，其實可以透過更簡短方式<?=$xxx; ?>直接印出來。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$str &#x3D; &quot;Hello Word&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;複雜</span><br><span class=\"line\">&lt;?php echo $str; ?&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;簡單</span><br><span class=\"line\">&lt;?&#x3D;$str; ?&gt;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;小結:其實簡單寫法是為了讓複雜程式碼更簡單更好閱讀，雖說沒有一定準則但是能讓程式碼更短不是好嗎。</p>\n","site":{"data":{"styles":""}},"excerpt":"前言\n使用PHP語言時是不是覺得code的語法很簡單或是方便，比期編譯語言程式碼如JAVA、C#、C等個要來得簡單，但是隨著需求功能增加code份量就會增加，這時候就是朝向clean code方面去開發，但本章節不是探討clean code的而是程式碼簡單寫法。\n\n何謂簡單寫法\n簡單寫法是一段程式碼從複雜到簡單，舉例來說條件式判斷常常占用到3行以上，下面這段條件式判斷，其實可以簡易條件式方式來縮短程式碼，來達到簡單程式碼。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n// 複雜\n$food = \"漢堡\";\n$eat = \"\";\n\nif($food == \"漢堡\")\n{\n    ","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;使用PHP語言時是不是覺得code的語法很簡單或是方便，比期編譯語言程式碼如JAVA、C#、C等個要來得簡單，但是隨著需求功能增加code份量就會增加，這時候就是朝向clean code方面去開發，但本章節不是探討clean code的而是<strong>程式碼簡單寫法</strong>。</p>\n<h4 id=\"何謂簡單寫法\"><a href=\"#何謂簡單寫法\" class=\"headerlink\" title=\"何謂簡單寫法\"></a>何謂簡單寫法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;簡單寫法是一段程式碼從複雜到簡單，舉例來說條件式判斷常常占用到3行以上，下面這段條件式判斷，其實可以簡易條件式方式來縮短程式碼，來達到簡單程式碼。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 複雜</span><br><span class=\"line\">$food &#x3D; &quot;漢堡&quot;;</span><br><span class=\"line\">$eat &#x3D; &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">if($food &#x3D;&#x3D; &quot;漢堡&quot;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $eat &#x3D; &quot;開動&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 簡單</span><br><span class=\"line\">$food &#x3D; &quot;漢堡&quot;;</span><br><span class=\"line\">$eat &#x3D; ($food &#x3D;&#x3D; &quot;漢堡&quot; ? &quot;開動&quot; : &quot;&quot;);</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;而如果是畫面上印出資料時需要透過echo or print，其實可以透過更簡短方式<?=$xxx; ?>直接印出來。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$str &#x3D; &quot;Hello Word&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;複雜</span><br><span class=\"line\">&lt;?php echo $str; ?&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;簡單</span><br><span class=\"line\">&lt;?&#x3D;$str; ?&gt;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;小結:其實簡單寫法是為了讓複雜程式碼更簡單更好閱讀，雖說沒有一定準則但是能讓程式碼更短不是好嗎。</p>\n"},{"title":"SQL 達人的工作現場攻略筆記 - CH-3 自我連結使用方式","date":"2020-11-17T15:50:49.000Z","type":"tags","_content":"\n#### 前言\n\nSQL 提供連結會依照特徵命名，分別為**內部連結**、**外部連結**、**交叉連結**這些，且這些連結通常會以不同的資料表為對象，但 SQL 並未禁止同一張表用連結，此時在同一張資料表套用連結稱為**自我連結 self join**。\n\n#### 一、重複排序、排列、結合\n\n假設有張表商品與價錢資料表、其中共有蘋果、橘子、香蕉三筆記錄不得不製作業績表時候，必須取得商品組合。\n\n| name(產品名稱) | price (價錢) |\n| -------------- | ------------ |\n| 蘋果           | 100          |\n| 橘子           | 50           |\n| 香蕉           | 80           |\n\n說是組合其實組合的種類有兩種，一種是重視的排列順序**有序數對**(ordered pair)，另一種是不重視順序的**無序數對**(unordered pair)。要建立有序數對非常簡單，例如:\n\n```sql\n建立重複排序SQL\nSELECT P1.name AS name_1, P2.name AS name_2　\nFROM Products P1 CROSS JOIN Products P2;\n```\n\n結果:\n\n| name_1 | name_2 |\n| ------ | ------ |\n| 蘋果   | 蘋果   |\n| 蘋果   | 橘子   |\n| 蘋果   | 香蕉   |\n| 橘子   | 蘋果   |\n| 橘子   | 橘子   |\n| 橘子   | 香蕉   |\n| 香蕉   | 蘋果   |\n| 香蕉   | 橘子   |\n| 香蕉   | 香蕉   |\n\n交叉連接為兩個資料表間的笛卡兒乘積 (Cartesian product)，兩個資料表在結合時，不指定任何條件，即將兩個資料表中所有的可能排列組合出來。可以看到這種連結方式出現很多多餘的組合，這都是因為重視順序的集合，此外也可以將交叉連結寫成以下方式‧\n\n```sql\n交叉連結另一種寫法\nSELECT P1.name AS name_1, P2.name AS name_2　\nFROM Products P1, Products P2;\n```\n\n此時作者卻說這種語法不要使用，原因是因為希望執行設有連結條件的內部連結，卻有可能忘記撰寫連結條件而變成交叉連結，產生預料之外的結果，交叉連結會消耗少不資源。接著將程式碼改寫成排除多餘的集合內容。首先排除(蘋果，蘋果)這種元素組合。\n\n```sql\n取得排列SQL\nSELECT P1.name AS name_1, P2.name AS name_2　\nFROM Products P1 INNER JOIN Products P2 ON P1.name <> P2.name;\n```\n\n結果:\n\n| name_1 | name_2 |\n| ------ | ------ |\n| 蘋果   | 橘子   |\n| 蘋果   | 香蕉   |\n| 橘子   | 蘋果   |\n| 橘子   | 香蕉   |\n| 香蕉   | 蘋果   |\n| 香蕉   | 橘子   |\n\n> ಠ_ಠ CROSS JOIN mysql 是舊版可能不支援此寫法，就會有使用 FROM table1,table2 方式。\n\n早期語法可能使用下列，但只要錯誤一步就有可能會寫成剛剛的交叉連結，所以盡可能不要使用此寫法。原因是因為忘記加上 WHERE 條件就會執行交叉連結，但若是使用 INNER JOIN 的語法就算忘記大部的 DBMS 都會視為語法錯誤。\n\n```sql\n取得排列SQL\nSELECT P1.name AS name_1, P2.name AS name_2　\nFROM Products P1, Products P2\nWHERE P1.name <> P2.name;\n```\n\n這裡說明如果上面忘記轉寫條件又會變成交叉連結，但使用 INNER JOIN 方式忘記寫條件系統就會噴錯，算是一種安全的寫法。接下來作者叫我們嘗試排除(蘋果、橘子)與(橘子、蘋果)這種只是調換順序組合。\n\n```sql\n取得組合SQL\nSELECT P1.name AS name_1, P2.name AS name_2\n  FROM Products P1\n  INNER JOIN Products P2 ON P1.name > P2.name\n```\n\n結果:\n\n| name_1 | name_2 |\n| ------ | ------ |\n| 蘋果   | 橘子   |\n| 香蕉   | 橘子   |\n| 香蕉   | 蘋果   |\n\n若想取得三種以上得組合，只需將程式碼改成以下內容。\n\n```sql\n取得組合SQL 擴充三欄位版本\nSELECT P1.name AS name_1,\n       P2.name AS name_2,　\n       P3.name AS name_3,\n  FROM Products P1\n  INNER JOIN Products P2 ON P1.name > P2.name\n  INNER JOIN Products P3 ON P2.name > P3.name;\n```\n\n結果:\n\n| name_1 | name_2 | name_3 |\n| ------ | ------ | ------ |\n| 蘋果   | 橘子   | 香蕉   |\n\n除了例題使用的=之外，使用>、<、<>這種比較運算子連結稱為**非等值連結**。這種連結與自我連結一起使用也稱為**自我非等值連結**。這種一般來說不太會在商業邏輯使用，但會建立在欄位組合使用。\n\n#### 二、刪除重複列\n\n在關聯式資料世界裡，重複列與 NULL 差不多是令人討厭，所以也有許多排列重複列的方法因此問世。用剛剛產品資料表例子，試著排除重複出現橘子，而這張表沒有設定Key。\n\n```sql\n刪除重複列SQL\nDELETE FROM Products P1\nWHERE rowid < (SELECT MAX(P2.rowid)\nFROM Products P2 WHERE P1.name = P2.name AND P1.price = P2.price);\n```\n\n這裡使用方式是虛擬欄位去取得列的編號因為這張表沒有設定Key關係，而在mysql中是名稱是使用_rowid，\n在SQL裡擁有不同名稱的集合被當成不同的集合，即使物理層級相同的存在，在邏輯層級仍屬於不同的存在。\n\n#### 三、部分不一致的 Key 搜尋\n\n| name(姓名) | family_id(家庭 ID) | address(地址)             |\n| ---------- | ------------------ | ------------------------- |\n| 許郁文     | 100                | 台北市萬華區長泰街 3-2-29 |\n| 許美美     | 100                | 台北市萬華區長泰街 3-2-92 |\n| 張瑋礽     | 200                | 台北市中正區南海路 2-8-1  |\n| 張銘仁     | 200                | 台北市中正區南海路 2-8-1  |\n| Holmes     | 300                | 貝克街 221B               |\n| Watson     | 400                | 貝克街 221B               |\n\n接下來將下列聯絡人資料表為例。主 Key 是人名，同一家族的人使用相同家族 ID，基本上同一家人會有相同的地址，但也有像是 Holmes 跟 Watson 這種還不是家人卻同居的情侶，書中是說將目光放在許家夫妻上，這兩個人並不是分居而是地址有誤，以這種情況如何篩選出是同一家人但地址卻不一致的紀錄呢?\n\n```sql\n搜尋同一家人，地址不同的SQL\nSELECT DISTINCT A1.name,A1.address\nFROM Address A1 INNER JOIN Address A2 ON A1.family_id = A2.family_id\nAND A1.address <> A2.address;\n```\n\n> 方法有很多種但如果是自我非等值連結撰寫，就能將程式碼寫得很簡潔。\n\n從下面商品資料表找出相同價格商品\n\n| name(商品名稱) | price(價格) |\n| -------------- | ----------- |\n| 蘋果           | 50          |\n| 橘子           | 100         |\n| 葡萄           | 50          |\n| 西瓜           | 80          |\n| 檸檬           | 30          |\n| 草莓           | 100         |\n| 香蕉           | 100         |\n\n```sql\n搜尋價格相同，商品名稱卻不同SQL\nSELECT DISTINCT A1.name,A1.price\nFROM Product A1 INNER JOIN Product A2 ON A1.price = A2.price\nAND A1.name <> A2.name\nORDER BY P1.price;\n```\n\n結果:\n\n| name(商品名稱) | price(價格) |\n| -------------- | ----------- |\n| 蘋果           | 50          |\n| 葡萄           | 50          |\n| 草莓           | 100         |\n| 橘子           | 100         |\n| 香蕉           | 100         |\n\n#### 四、總結\n\n自我連結就是利用自身表去找出想要的資料。\n\n1.自我連結通常會與非等值連結搭配使用。\n\n2.與 GROUP BY 組合可建立遞迴性集合。\n\n3.想成是讓不同資料表連結。\n\n4.從邏輯層級思考，而不是物理層級。\n\n參考資料: \n\n1.SQL 達人的工作現場攻略筆","source":"_posts/sql/202011172350.md","raw":"---\ntitle: SQL 達人的工作現場攻略筆記 - CH-3 自我連結使用方式\ndate: 2020-11-17 23:50:49\ntype: \"tags\"\ncategories: 資料庫\ntags: 資料庫\n---\n\n#### 前言\n\nSQL 提供連結會依照特徵命名，分別為**內部連結**、**外部連結**、**交叉連結**這些，且這些連結通常會以不同的資料表為對象，但 SQL 並未禁止同一張表用連結，此時在同一張資料表套用連結稱為**自我連結 self join**。\n\n#### 一、重複排序、排列、結合\n\n假設有張表商品與價錢資料表、其中共有蘋果、橘子、香蕉三筆記錄不得不製作業績表時候，必須取得商品組合。\n\n| name(產品名稱) | price (價錢) |\n| -------------- | ------------ |\n| 蘋果           | 100          |\n| 橘子           | 50           |\n| 香蕉           | 80           |\n\n說是組合其實組合的種類有兩種，一種是重視的排列順序**有序數對**(ordered pair)，另一種是不重視順序的**無序數對**(unordered pair)。要建立有序數對非常簡單，例如:\n\n```sql\n建立重複排序SQL\nSELECT P1.name AS name_1, P2.name AS name_2　\nFROM Products P1 CROSS JOIN Products P2;\n```\n\n結果:\n\n| name_1 | name_2 |\n| ------ | ------ |\n| 蘋果   | 蘋果   |\n| 蘋果   | 橘子   |\n| 蘋果   | 香蕉   |\n| 橘子   | 蘋果   |\n| 橘子   | 橘子   |\n| 橘子   | 香蕉   |\n| 香蕉   | 蘋果   |\n| 香蕉   | 橘子   |\n| 香蕉   | 香蕉   |\n\n交叉連接為兩個資料表間的笛卡兒乘積 (Cartesian product)，兩個資料表在結合時，不指定任何條件，即將兩個資料表中所有的可能排列組合出來。可以看到這種連結方式出現很多多餘的組合，這都是因為重視順序的集合，此外也可以將交叉連結寫成以下方式‧\n\n```sql\n交叉連結另一種寫法\nSELECT P1.name AS name_1, P2.name AS name_2　\nFROM Products P1, Products P2;\n```\n\n此時作者卻說這種語法不要使用，原因是因為希望執行設有連結條件的內部連結，卻有可能忘記撰寫連結條件而變成交叉連結，產生預料之外的結果，交叉連結會消耗少不資源。接著將程式碼改寫成排除多餘的集合內容。首先排除(蘋果，蘋果)這種元素組合。\n\n```sql\n取得排列SQL\nSELECT P1.name AS name_1, P2.name AS name_2　\nFROM Products P1 INNER JOIN Products P2 ON P1.name <> P2.name;\n```\n\n結果:\n\n| name_1 | name_2 |\n| ------ | ------ |\n| 蘋果   | 橘子   |\n| 蘋果   | 香蕉   |\n| 橘子   | 蘋果   |\n| 橘子   | 香蕉   |\n| 香蕉   | 蘋果   |\n| 香蕉   | 橘子   |\n\n> ಠ_ಠ CROSS JOIN mysql 是舊版可能不支援此寫法，就會有使用 FROM table1,table2 方式。\n\n早期語法可能使用下列，但只要錯誤一步就有可能會寫成剛剛的交叉連結，所以盡可能不要使用此寫法。原因是因為忘記加上 WHERE 條件就會執行交叉連結，但若是使用 INNER JOIN 的語法就算忘記大部的 DBMS 都會視為語法錯誤。\n\n```sql\n取得排列SQL\nSELECT P1.name AS name_1, P2.name AS name_2　\nFROM Products P1, Products P2\nWHERE P1.name <> P2.name;\n```\n\n這裡說明如果上面忘記轉寫條件又會變成交叉連結，但使用 INNER JOIN 方式忘記寫條件系統就會噴錯，算是一種安全的寫法。接下來作者叫我們嘗試排除(蘋果、橘子)與(橘子、蘋果)這種只是調換順序組合。\n\n```sql\n取得組合SQL\nSELECT P1.name AS name_1, P2.name AS name_2\n  FROM Products P1\n  INNER JOIN Products P2 ON P1.name > P2.name\n```\n\n結果:\n\n| name_1 | name_2 |\n| ------ | ------ |\n| 蘋果   | 橘子   |\n| 香蕉   | 橘子   |\n| 香蕉   | 蘋果   |\n\n若想取得三種以上得組合，只需將程式碼改成以下內容。\n\n```sql\n取得組合SQL 擴充三欄位版本\nSELECT P1.name AS name_1,\n       P2.name AS name_2,　\n       P3.name AS name_3,\n  FROM Products P1\n  INNER JOIN Products P2 ON P1.name > P2.name\n  INNER JOIN Products P3 ON P2.name > P3.name;\n```\n\n結果:\n\n| name_1 | name_2 | name_3 |\n| ------ | ------ | ------ |\n| 蘋果   | 橘子   | 香蕉   |\n\n除了例題使用的=之外，使用>、<、<>這種比較運算子連結稱為**非等值連結**。這種連結與自我連結一起使用也稱為**自我非等值連結**。這種一般來說不太會在商業邏輯使用，但會建立在欄位組合使用。\n\n#### 二、刪除重複列\n\n在關聯式資料世界裡，重複列與 NULL 差不多是令人討厭，所以也有許多排列重複列的方法因此問世。用剛剛產品資料表例子，試著排除重複出現橘子，而這張表沒有設定Key。\n\n```sql\n刪除重複列SQL\nDELETE FROM Products P1\nWHERE rowid < (SELECT MAX(P2.rowid)\nFROM Products P2 WHERE P1.name = P2.name AND P1.price = P2.price);\n```\n\n這裡使用方式是虛擬欄位去取得列的編號因為這張表沒有設定Key關係，而在mysql中是名稱是使用_rowid，\n在SQL裡擁有不同名稱的集合被當成不同的集合，即使物理層級相同的存在，在邏輯層級仍屬於不同的存在。\n\n#### 三、部分不一致的 Key 搜尋\n\n| name(姓名) | family_id(家庭 ID) | address(地址)             |\n| ---------- | ------------------ | ------------------------- |\n| 許郁文     | 100                | 台北市萬華區長泰街 3-2-29 |\n| 許美美     | 100                | 台北市萬華區長泰街 3-2-92 |\n| 張瑋礽     | 200                | 台北市中正區南海路 2-8-1  |\n| 張銘仁     | 200                | 台北市中正區南海路 2-8-1  |\n| Holmes     | 300                | 貝克街 221B               |\n| Watson     | 400                | 貝克街 221B               |\n\n接下來將下列聯絡人資料表為例。主 Key 是人名，同一家族的人使用相同家族 ID，基本上同一家人會有相同的地址，但也有像是 Holmes 跟 Watson 這種還不是家人卻同居的情侶，書中是說將目光放在許家夫妻上，這兩個人並不是分居而是地址有誤，以這種情況如何篩選出是同一家人但地址卻不一致的紀錄呢?\n\n```sql\n搜尋同一家人，地址不同的SQL\nSELECT DISTINCT A1.name,A1.address\nFROM Address A1 INNER JOIN Address A2 ON A1.family_id = A2.family_id\nAND A1.address <> A2.address;\n```\n\n> 方法有很多種但如果是自我非等值連結撰寫，就能將程式碼寫得很簡潔。\n\n從下面商品資料表找出相同價格商品\n\n| name(商品名稱) | price(價格) |\n| -------------- | ----------- |\n| 蘋果           | 50          |\n| 橘子           | 100         |\n| 葡萄           | 50          |\n| 西瓜           | 80          |\n| 檸檬           | 30          |\n| 草莓           | 100         |\n| 香蕉           | 100         |\n\n```sql\n搜尋價格相同，商品名稱卻不同SQL\nSELECT DISTINCT A1.name,A1.price\nFROM Product A1 INNER JOIN Product A2 ON A1.price = A2.price\nAND A1.name <> A2.name\nORDER BY P1.price;\n```\n\n結果:\n\n| name(商品名稱) | price(價格) |\n| -------------- | ----------- |\n| 蘋果           | 50          |\n| 葡萄           | 50          |\n| 草莓           | 100         |\n| 橘子           | 100         |\n| 香蕉           | 100         |\n\n#### 四、總結\n\n自我連結就是利用自身表去找出想要的資料。\n\n1.自我連結通常會與非等值連結搭配使用。\n\n2.與 GROUP BY 組合可建立遞迴性集合。\n\n3.想成是讓不同資料表連結。\n\n4.從邏輯層級思考，而不是物理層級。\n\n參考資料: \n\n1.SQL 達人的工作現場攻略筆","slug":"sql/202011172350","published":1,"updated":"2022-03-16T13:14:48.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0tlcc630004fx7rfem46lmu","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>SQL 提供連結會依照特徵命名，分別為<strong>內部連結</strong>、<strong>外部連結</strong>、<strong>交叉連結</strong>這些，且這些連結通常會以不同的資料表為對象，但 SQL 並未禁止同一張表用連結，此時在同一張資料表套用連結稱為<strong>自我連結 self join</strong>。</p>\n<h4 id=\"一、重複排序、排列、結合\"><a href=\"#一、重複排序、排列、結合\" class=\"headerlink\" title=\"一、重複排序、排列、結合\"></a>一、重複排序、排列、結合</h4><p>假設有張表商品與價錢資料表、其中共有蘋果、橘子、香蕉三筆記錄不得不製作業績表時候，必須取得商品組合。</p>\n<table>\n<thead>\n<tr>\n<th>name(產品名稱)</th>\n<th>price (價錢)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>100</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>50</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>80</td>\n</tr>\n</tbody></table>\n<p>說是組合其實組合的種類有兩種，一種是重視的排列順序<strong>有序數對</strong>(ordered pair)，另一種是不重視順序的<strong>無序數對</strong>(unordered pair)。要建立有序數對非常簡單，例如:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">建立重複排序SQL</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> P1.name <span class=\"keyword\">AS</span> name_1, P2.name <span class=\"keyword\">AS</span> name_2　</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Products P1 <span class=\"keyword\">CROSS</span> <span class=\"keyword\">JOIN</span> Products P2;</span><br></pre></td></tr></table></figure>\n\n<p>結果:</p>\n<table>\n<thead>\n<tr>\n<th>name_1</th>\n<th>name_2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>蘋果</td>\n</tr>\n<tr>\n<td>蘋果</td>\n<td>橘子</td>\n</tr>\n<tr>\n<td>蘋果</td>\n<td>香蕉</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>蘋果</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>橘子</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>香蕉</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>蘋果</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>橘子</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>香蕉</td>\n</tr>\n</tbody></table>\n<p>交叉連接為兩個資料表間的笛卡兒乘積 (Cartesian product)，兩個資料表在結合時，不指定任何條件，即將兩個資料表中所有的可能排列組合出來。可以看到這種連結方式出現很多多餘的組合，這都是因為重視順序的集合，此外也可以將交叉連結寫成以下方式‧</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">交叉連結另一種寫法</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> P1.name <span class=\"keyword\">AS</span> name_1, P2.name <span class=\"keyword\">AS</span> name_2　</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Products P1, Products P2;</span><br></pre></td></tr></table></figure>\n\n<p>此時作者卻說這種語法不要使用，原因是因為希望執行設有連結條件的內部連結，卻有可能忘記撰寫連結條件而變成交叉連結，產生預料之外的結果，交叉連結會消耗少不資源。接著將程式碼改寫成排除多餘的集合內容。首先排除(蘋果，蘋果)這種元素組合。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">取得排列SQL</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> P1.name <span class=\"keyword\">AS</span> name_1, P2.name <span class=\"keyword\">AS</span> name_2　</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Products P1 <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Products P2 <span class=\"keyword\">ON</span> P1.name &lt;&gt; P2.name;</span><br></pre></td></tr></table></figure>\n\n<p>結果:</p>\n<table>\n<thead>\n<tr>\n<th>name_1</th>\n<th>name_2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>橘子</td>\n</tr>\n<tr>\n<td>蘋果</td>\n<td>香蕉</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>蘋果</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>香蕉</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>蘋果</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>橘子</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>ಠ_ಠ CROSS JOIN mysql 是舊版可能不支援此寫法，就會有使用 FROM table1,table2 方式。</p>\n</blockquote>\n<p>早期語法可能使用下列，但只要錯誤一步就有可能會寫成剛剛的交叉連結，所以盡可能不要使用此寫法。原因是因為忘記加上 WHERE 條件就會執行交叉連結，但若是使用 INNER JOIN 的語法就算忘記大部的 DBMS 都會視為語法錯誤。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">取得排列SQL</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> P1.name <span class=\"keyword\">AS</span> name_1, P2.name <span class=\"keyword\">AS</span> name_2　</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Products P1, Products P2</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> P1.name &lt;&gt; P2.name;</span><br></pre></td></tr></table></figure>\n\n<p>這裡說明如果上面忘記轉寫條件又會變成交叉連結，但使用 INNER JOIN 方式忘記寫條件系統就會噴錯，算是一種安全的寫法。接下來作者叫我們嘗試排除(蘋果、橘子)與(橘子、蘋果)這種只是調換順序組合。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">取得組合SQL</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> P1.name <span class=\"keyword\">AS</span> name_1, P2.name <span class=\"keyword\">AS</span> name_2</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> Products P1</span><br><span class=\"line\">  <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Products P2 <span class=\"keyword\">ON</span> P1.name &gt; P2.name</span><br></pre></td></tr></table></figure>\n\n<p>結果:</p>\n<table>\n<thead>\n<tr>\n<th>name_1</th>\n<th>name_2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>橘子</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>橘子</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>蘋果</td>\n</tr>\n</tbody></table>\n<p>若想取得三種以上得組合，只需將程式碼改成以下內容。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">取得組合SQL 擴充三欄位版本</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> P1.name <span class=\"keyword\">AS</span> name_1,</span><br><span class=\"line\">       P2.name <span class=\"keyword\">AS</span> name_2,　</span><br><span class=\"line\">       P3.name <span class=\"keyword\">AS</span> name_3,</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> Products P1</span><br><span class=\"line\">  <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Products P2 <span class=\"keyword\">ON</span> P1.name &gt; P2.name</span><br><span class=\"line\">  <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Products P3 <span class=\"keyword\">ON</span> P2.name &gt; P3.name;</span><br></pre></td></tr></table></figure>\n\n<p>結果:</p>\n<table>\n<thead>\n<tr>\n<th>name_1</th>\n<th>name_2</th>\n<th>name_3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>橘子</td>\n<td>香蕉</td>\n</tr>\n</tbody></table>\n<p>除了例題使用的=之外，使用&gt;、&lt;、&lt;&gt;這種比較運算子連結稱為<strong>非等值連結</strong>。這種連結與自我連結一起使用也稱為<strong>自我非等值連結</strong>。這種一般來說不太會在商業邏輯使用，但會建立在欄位組合使用。</p>\n<h4 id=\"二、刪除重複列\"><a href=\"#二、刪除重複列\" class=\"headerlink\" title=\"二、刪除重複列\"></a>二、刪除重複列</h4><p>在關聯式資料世界裡，重複列與 NULL 差不多是令人討厭，所以也有許多排列重複列的方法因此問世。用剛剛產品資料表例子，試著排除重複出現橘子，而這張表沒有設定Key。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">刪除重複列SQL</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> Products P1</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">rowid</span> &lt; (<span class=\"keyword\">SELECT</span> <span class=\"keyword\">MAX</span>(P2.rowid)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Products P2 <span class=\"keyword\">WHERE</span> P1.name = P2.name <span class=\"keyword\">AND</span> P1.price = P2.price);</span><br></pre></td></tr></table></figure>\n\n<p>這裡使用方式是虛擬欄位去取得列的編號因為這張表沒有設定Key關係，而在mysql中是名稱是使用_rowid，<br>在SQL裡擁有不同名稱的集合被當成不同的集合，即使物理層級相同的存在，在邏輯層級仍屬於不同的存在。</p>\n<h4 id=\"三、部分不一致的-Key-搜尋\"><a href=\"#三、部分不一致的-Key-搜尋\" class=\"headerlink\" title=\"三、部分不一致的 Key 搜尋\"></a>三、部分不一致的 Key 搜尋</h4><table>\n<thead>\n<tr>\n<th>name(姓名)</th>\n<th>family_id(家庭 ID)</th>\n<th>address(地址)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>許郁文</td>\n<td>100</td>\n<td>台北市萬華區長泰街 3-2-29</td>\n</tr>\n<tr>\n<td>許美美</td>\n<td>100</td>\n<td>台北市萬華區長泰街 3-2-92</td>\n</tr>\n<tr>\n<td>張瑋礽</td>\n<td>200</td>\n<td>台北市中正區南海路 2-8-1</td>\n</tr>\n<tr>\n<td>張銘仁</td>\n<td>200</td>\n<td>台北市中正區南海路 2-8-1</td>\n</tr>\n<tr>\n<td>Holmes</td>\n<td>300</td>\n<td>貝克街 221B</td>\n</tr>\n<tr>\n<td>Watson</td>\n<td>400</td>\n<td>貝克街 221B</td>\n</tr>\n</tbody></table>\n<p>接下來將下列聯絡人資料表為例。主 Key 是人名，同一家族的人使用相同家族 ID，基本上同一家人會有相同的地址，但也有像是 Holmes 跟 Watson 這種還不是家人卻同居的情侶，書中是說將目光放在許家夫妻上，這兩個人並不是分居而是地址有誤，以這種情況如何篩選出是同一家人但地址卻不一致的紀錄呢?</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜尋同一家人，地址不同的SQL</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> A1.name,A1.address</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Address A1 <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Address A2 <span class=\"keyword\">ON</span> A1.family_id = A2.family_id</span><br><span class=\"line\"><span class=\"keyword\">AND</span> A1.address &lt;&gt; A2.address;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>方法有很多種但如果是自我非等值連結撰寫，就能將程式碼寫得很簡潔。</p>\n</blockquote>\n<p>從下面商品資料表找出相同價格商品</p>\n<table>\n<thead>\n<tr>\n<th>name(商品名稱)</th>\n<th>price(價格)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>50</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>100</td>\n</tr>\n<tr>\n<td>葡萄</td>\n<td>50</td>\n</tr>\n<tr>\n<td>西瓜</td>\n<td>80</td>\n</tr>\n<tr>\n<td>檸檬</td>\n<td>30</td>\n</tr>\n<tr>\n<td>草莓</td>\n<td>100</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜尋價格相同，商品名稱卻不同SQL</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> A1.name,A1.price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Product A1 <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Product A2 <span class=\"keyword\">ON</span> A1.price = A2.price</span><br><span class=\"line\"><span class=\"keyword\">AND</span> A1.name &lt;&gt; A2.name</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> P1.price;</span><br></pre></td></tr></table></figure>\n\n<p>結果:</p>\n<table>\n<thead>\n<tr>\n<th>name(商品名稱)</th>\n<th>price(價格)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>50</td>\n</tr>\n<tr>\n<td>葡萄</td>\n<td>50</td>\n</tr>\n<tr>\n<td>草莓</td>\n<td>100</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>100</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<h4 id=\"四、總結\"><a href=\"#四、總結\" class=\"headerlink\" title=\"四、總結\"></a>四、總結</h4><p>自我連結就是利用自身表去找出想要的資料。</p>\n<p>1.自我連結通常會與非等值連結搭配使用。</p>\n<p>2.與 GROUP BY 組合可建立遞迴性集合。</p>\n<p>3.想成是讓不同資料表連結。</p>\n<p>4.從邏輯層級思考，而不是物理層級。</p>\n<p>參考資料: </p>\n<p>1.SQL 達人的工作現場攻略筆</p>\n","site":{"data":{"styles":""}},"excerpt":"前言\nSQL 提供連結會依照特徵命名，分別為內部連結、外部連結、交叉連結這些，且這些連結通常會以不同的資料表為對象，但 SQL 並未禁止同一張表用連結，此時在同一張資料表套用連結稱為自我連結 self join。\n\n一、重複排序、排列、結合\n假設有張表商品與價錢資料表、其中共有蘋果、橘子、香蕉三筆記錄不得不製作業績表時候，必須取得商品組合。\n\nname(產品名稱)price (價錢)蘋果100橘子50香蕉80說是組合其實組合的種類有兩種，一種是重視的排列順序有序數對(ordered pair)，另一種是不重視順序的無序數對(unordered pair)。要建立有序數對非常簡單，例如:\n\n1\n","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>SQL 提供連結會依照特徵命名，分別為<strong>內部連結</strong>、<strong>外部連結</strong>、<strong>交叉連結</strong>這些，且這些連結通常會以不同的資料表為對象，但 SQL 並未禁止同一張表用連結，此時在同一張資料表套用連結稱為<strong>自我連結 self join</strong>。</p>\n<h4 id=\"一、重複排序、排列、結合\"><a href=\"#一、重複排序、排列、結合\" class=\"headerlink\" title=\"一、重複排序、排列、結合\"></a>一、重複排序、排列、結合</h4><p>假設有張表商品與價錢資料表、其中共有蘋果、橘子、香蕉三筆記錄不得不製作業績表時候，必須取得商品組合。</p>\n<table>\n<thead>\n<tr>\n<th>name(產品名稱)</th>\n<th>price (價錢)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>100</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>50</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>80</td>\n</tr>\n</tbody></table>\n<p>說是組合其實組合的種類有兩種，一種是重視的排列順序<strong>有序數對</strong>(ordered pair)，另一種是不重視順序的<strong>無序數對</strong>(unordered pair)。要建立有序數對非常簡單，例如:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">建立重複排序SQL</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> P1.name <span class=\"keyword\">AS</span> name_1, P2.name <span class=\"keyword\">AS</span> name_2　</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Products P1 <span class=\"keyword\">CROSS</span> <span class=\"keyword\">JOIN</span> Products P2;</span><br></pre></td></tr></table></figure>\n\n<p>結果:</p>\n<table>\n<thead>\n<tr>\n<th>name_1</th>\n<th>name_2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>蘋果</td>\n</tr>\n<tr>\n<td>蘋果</td>\n<td>橘子</td>\n</tr>\n<tr>\n<td>蘋果</td>\n<td>香蕉</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>蘋果</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>橘子</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>香蕉</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>蘋果</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>橘子</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>香蕉</td>\n</tr>\n</tbody></table>\n<p>交叉連接為兩個資料表間的笛卡兒乘積 (Cartesian product)，兩個資料表在結合時，不指定任何條件，即將兩個資料表中所有的可能排列組合出來。可以看到這種連結方式出現很多多餘的組合，這都是因為重視順序的集合，此外也可以將交叉連結寫成以下方式‧</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">交叉連結另一種寫法</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> P1.name <span class=\"keyword\">AS</span> name_1, P2.name <span class=\"keyword\">AS</span> name_2　</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Products P1, Products P2;</span><br></pre></td></tr></table></figure>\n\n<p>此時作者卻說這種語法不要使用，原因是因為希望執行設有連結條件的內部連結，卻有可能忘記撰寫連結條件而變成交叉連結，產生預料之外的結果，交叉連結會消耗少不資源。接著將程式碼改寫成排除多餘的集合內容。首先排除(蘋果，蘋果)這種元素組合。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">取得排列SQL</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> P1.name <span class=\"keyword\">AS</span> name_1, P2.name <span class=\"keyword\">AS</span> name_2　</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Products P1 <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Products P2 <span class=\"keyword\">ON</span> P1.name &lt;&gt; P2.name;</span><br></pre></td></tr></table></figure>\n\n<p>結果:</p>\n<table>\n<thead>\n<tr>\n<th>name_1</th>\n<th>name_2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>橘子</td>\n</tr>\n<tr>\n<td>蘋果</td>\n<td>香蕉</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>蘋果</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>香蕉</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>蘋果</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>橘子</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>ಠ_ಠ CROSS JOIN mysql 是舊版可能不支援此寫法，就會有使用 FROM table1,table2 方式。</p>\n</blockquote>\n<p>早期語法可能使用下列，但只要錯誤一步就有可能會寫成剛剛的交叉連結，所以盡可能不要使用此寫法。原因是因為忘記加上 WHERE 條件就會執行交叉連結，但若是使用 INNER JOIN 的語法就算忘記大部的 DBMS 都會視為語法錯誤。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">取得排列SQL</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> P1.name <span class=\"keyword\">AS</span> name_1, P2.name <span class=\"keyword\">AS</span> name_2　</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Products P1, Products P2</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> P1.name &lt;&gt; P2.name;</span><br></pre></td></tr></table></figure>\n\n<p>這裡說明如果上面忘記轉寫條件又會變成交叉連結，但使用 INNER JOIN 方式忘記寫條件系統就會噴錯，算是一種安全的寫法。接下來作者叫我們嘗試排除(蘋果、橘子)與(橘子、蘋果)這種只是調換順序組合。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">取得組合SQL</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> P1.name <span class=\"keyword\">AS</span> name_1, P2.name <span class=\"keyword\">AS</span> name_2</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> Products P1</span><br><span class=\"line\">  <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Products P2 <span class=\"keyword\">ON</span> P1.name &gt; P2.name</span><br></pre></td></tr></table></figure>\n\n<p>結果:</p>\n<table>\n<thead>\n<tr>\n<th>name_1</th>\n<th>name_2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>橘子</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>橘子</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>蘋果</td>\n</tr>\n</tbody></table>\n<p>若想取得三種以上得組合，只需將程式碼改成以下內容。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">取得組合SQL 擴充三欄位版本</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> P1.name <span class=\"keyword\">AS</span> name_1,</span><br><span class=\"line\">       P2.name <span class=\"keyword\">AS</span> name_2,　</span><br><span class=\"line\">       P3.name <span class=\"keyword\">AS</span> name_3,</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> Products P1</span><br><span class=\"line\">  <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Products P2 <span class=\"keyword\">ON</span> P1.name &gt; P2.name</span><br><span class=\"line\">  <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Products P3 <span class=\"keyword\">ON</span> P2.name &gt; P3.name;</span><br></pre></td></tr></table></figure>\n\n<p>結果:</p>\n<table>\n<thead>\n<tr>\n<th>name_1</th>\n<th>name_2</th>\n<th>name_3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>橘子</td>\n<td>香蕉</td>\n</tr>\n</tbody></table>\n<p>除了例題使用的=之外，使用&gt;、&lt;、&lt;&gt;這種比較運算子連結稱為<strong>非等值連結</strong>。這種連結與自我連結一起使用也稱為<strong>自我非等值連結</strong>。這種一般來說不太會在商業邏輯使用，但會建立在欄位組合使用。</p>\n<h4 id=\"二、刪除重複列\"><a href=\"#二、刪除重複列\" class=\"headerlink\" title=\"二、刪除重複列\"></a>二、刪除重複列</h4><p>在關聯式資料世界裡，重複列與 NULL 差不多是令人討厭，所以也有許多排列重複列的方法因此問世。用剛剛產品資料表例子，試著排除重複出現橘子，而這張表沒有設定Key。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">刪除重複列SQL</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> Products P1</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">rowid</span> &lt; (<span class=\"keyword\">SELECT</span> <span class=\"keyword\">MAX</span>(P2.rowid)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Products P2 <span class=\"keyword\">WHERE</span> P1.name = P2.name <span class=\"keyword\">AND</span> P1.price = P2.price);</span><br></pre></td></tr></table></figure>\n\n<p>這裡使用方式是虛擬欄位去取得列的編號因為這張表沒有設定Key關係，而在mysql中是名稱是使用_rowid，<br>在SQL裡擁有不同名稱的集合被當成不同的集合，即使物理層級相同的存在，在邏輯層級仍屬於不同的存在。</p>\n<h4 id=\"三、部分不一致的-Key-搜尋\"><a href=\"#三、部分不一致的-Key-搜尋\" class=\"headerlink\" title=\"三、部分不一致的 Key 搜尋\"></a>三、部分不一致的 Key 搜尋</h4><table>\n<thead>\n<tr>\n<th>name(姓名)</th>\n<th>family_id(家庭 ID)</th>\n<th>address(地址)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>許郁文</td>\n<td>100</td>\n<td>台北市萬華區長泰街 3-2-29</td>\n</tr>\n<tr>\n<td>許美美</td>\n<td>100</td>\n<td>台北市萬華區長泰街 3-2-92</td>\n</tr>\n<tr>\n<td>張瑋礽</td>\n<td>200</td>\n<td>台北市中正區南海路 2-8-1</td>\n</tr>\n<tr>\n<td>張銘仁</td>\n<td>200</td>\n<td>台北市中正區南海路 2-8-1</td>\n</tr>\n<tr>\n<td>Holmes</td>\n<td>300</td>\n<td>貝克街 221B</td>\n</tr>\n<tr>\n<td>Watson</td>\n<td>400</td>\n<td>貝克街 221B</td>\n</tr>\n</tbody></table>\n<p>接下來將下列聯絡人資料表為例。主 Key 是人名，同一家族的人使用相同家族 ID，基本上同一家人會有相同的地址，但也有像是 Holmes 跟 Watson 這種還不是家人卻同居的情侶，書中是說將目光放在許家夫妻上，這兩個人並不是分居而是地址有誤，以這種情況如何篩選出是同一家人但地址卻不一致的紀錄呢?</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜尋同一家人，地址不同的SQL</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> A1.name,A1.address</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Address A1 <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Address A2 <span class=\"keyword\">ON</span> A1.family_id = A2.family_id</span><br><span class=\"line\"><span class=\"keyword\">AND</span> A1.address &lt;&gt; A2.address;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>方法有很多種但如果是自我非等值連結撰寫，就能將程式碼寫得很簡潔。</p>\n</blockquote>\n<p>從下面商品資料表找出相同價格商品</p>\n<table>\n<thead>\n<tr>\n<th>name(商品名稱)</th>\n<th>price(價格)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>50</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>100</td>\n</tr>\n<tr>\n<td>葡萄</td>\n<td>50</td>\n</tr>\n<tr>\n<td>西瓜</td>\n<td>80</td>\n</tr>\n<tr>\n<td>檸檬</td>\n<td>30</td>\n</tr>\n<tr>\n<td>草莓</td>\n<td>100</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">搜尋價格相同，商品名稱卻不同SQL</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> A1.name,A1.price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Product A1 <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Product A2 <span class=\"keyword\">ON</span> A1.price = A2.price</span><br><span class=\"line\"><span class=\"keyword\">AND</span> A1.name &lt;&gt; A2.name</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> P1.price;</span><br></pre></td></tr></table></figure>\n\n<p>結果:</p>\n<table>\n<thead>\n<tr>\n<th>name(商品名稱)</th>\n<th>price(價格)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蘋果</td>\n<td>50</td>\n</tr>\n<tr>\n<td>葡萄</td>\n<td>50</td>\n</tr>\n<tr>\n<td>草莓</td>\n<td>100</td>\n</tr>\n<tr>\n<td>橘子</td>\n<td>100</td>\n</tr>\n<tr>\n<td>香蕉</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<h4 id=\"四、總結\"><a href=\"#四、總結\" class=\"headerlink\" title=\"四、總結\"></a>四、總結</h4><p>自我連結就是利用自身表去找出想要的資料。</p>\n<p>1.自我連結通常會與非等值連結搭配使用。</p>\n<p>2.與 GROUP BY 組合可建立遞迴性集合。</p>\n<p>3.想成是讓不同資料表連結。</p>\n<p>4.從邏輯層級思考，而不是物理層級。</p>\n<p>參考資料: </p>\n<p>1.SQL 達人的工作現場攻略筆</p>\n"},{"title":"SQL 達人的工作現場攻略筆記 - CH-11 要讓SQL加速囉","date":"2020-12-23T12:16:00.000Z","type":"tags","_content":"\n## 前言\n\nSQL 的效能一直是 DB 工程師必須面對的主要課程之一，甚至有些人認為是唯一的課題。此章節是改善 SQL 的效能，讓執行速度更快減少更多資源。\n\n## 使用效率的搜尋\n\n#### 若子查詢為參數\n\n使用(EXISTS)代替(IN)，在 IN 述詞很方便，也很好讀，但卻會遇到效能瓶頸的問題，若當 IN 參數(1,2,3)這種 List 時繼就不需要改寫，但如果以子查詢為參數就必須要注意，通常 NOT IN 跟 NOT EXISTS 都是回傳相同的結果，但是使用 EXISTS 建立子查詢卻快的很多。\n\nClass_A\n\n| id(識別子) |name (姓名) |\n| ----------| ------------ |\n| 1 | 郁 |\n| 2 | 瑋 |\n| 3 | 銘 |\n\nClass_B\n\n| id(識別子) | name(姓名) |\n| --------- | ------------ |\n| 1 | 郁 |\n| 2 | 瑋 |\n| 4 | 靚 |\n\n試著從 Class_A 表找出 Class_B 資料表也有的學生。\n\n```sql\n    較慢\n    SELECT * FROM Class_A WHERE id IN ( SELECT id FROM Class_B);\n```\n\n```sql\n    較快\n    SELECT * FROM Class_A A WHERE EXISTS ( SELECT id FROM Class_B B WHERE A.id = B.id );\n```\n\n結果\n\n| id(識別子) | name(姓名) |\n| --------- | ------------ |\n| 1 | 郁 |\n| 2 | 瑋 |\n\n```\n為什麼EXISTS會比較快？大致上有兩個理由。\n1.如果連結key帶有索引值，就可能直接按照索引值，不需觀察Class_B的資料表。\n2.EXISTS只要找到一筆符合的列，就會立刻停止搜尋，不會是IN得全面搜尋一遍。\n```\n\n#### 子查詢為參數時，使用連結代替 IN\n\n要改善 IN 的效能，除了使用 EXISTS 改寫，也可以利用連結方式去實現。\n\n```sql\n    SELECT Ａ.id,A.name FROM Class_A A INNER JOIN Class_B B ON A.id = B.id;\n```\n\n## 避開排序\n\nSQL 與程式語言不同，使用者無法直接命令 DBMS 指定排序運算，不過這不代表 DBMS 不執行排序，更精準的說是 DBMS 非常頻繁的偷偷執行排序，也導致使用者不用去理會哪中運算正在執行排序。\n\n會執行排序如下 :\n\n    1.GROUP BY\n    2.ORDER BY\n    3.彙總函數(SUM、COUNT、AVG、MAX、MIN)\n    4.DISTINCT\n    5.UNION、INTERSECT、EXCEPT\n    6.視窗函數(RANK ROW_NUMBER)\n\n#### 善用集合運算的 ALL 選項\n\nSQL具有UNION、INTERSECT、EXCEPT 三種集合運算子，如果直接使用一定會為了排除重複資料而執行排序。\n\n```sql\n    SELECT * FROM Class_A\n     UNION\n    SELECT * FROM Class_B;\n```\n\n結果\n\n| id(識別子) | name(姓名) |\n| --------- | ------------ |\n| 1 | 郁 |\n| 2 | 瑋 |\n| 3 | 銘 |\n| 4 | 靚 |\n\n如果不用在乎重複資料或事先知道不會有重複資料，可以利用 UNION ALL 代替，避免執行排序。\n\n#### 以 EXISTS 代替 DISTINCT\n\nDISTINCT 也會為了排除重複資料而執行排序。若是為了統整兩張表連結結果而使用 DISTINCT 的情況，也可以使用 EXISTS 代替，也能避免執行排序。\n\nItems\n\n| item_no|item |\n| ----------| ------------ |\n| 10| SD 記憶卡 |\n| 20 | CD-R |\n| 30 | USB 隨身碟|\n| 40 | DVD|\n\nSalesHistory\n\n| sale_date | item_no | quantity |\n| --------- | ------------ | ------------ |\n| 2020-10-01 | 10 | 4 |\n| 2020-10-01 | 20 | 10 |\n| 2020-10-01 | 30 | 3 |\n| 2020-10-03 | 10 | 32 |\n| 2020-10-03 | 30 | 12 |\n| 2020-10-04 | 20 | 22 |\n| 2020-10-04 | 30 | 7 |\n\n根據上方商品主資料表選出業績表的商品，簡單說就是找出有業績的商品，此時書中說使用IN雖然不錯。但前面提到用連結會更好。\n\n```sql\n    SELECT I.item_no FROM Items I INNER JOIN SalesHistory SH ON I.item_no = SH.item_no;\n```\n\n結果\n\n| item_no |\n| --------- |\n| 10|\n| 10|\n| 20|\n| 20|\n| 30|\n| 30|\n| 30|\n\n由於是一對多連結，就會出現重複資料，若要將重複資料排除勢必使用DISTINCT那這樣就會執行到排序，所以書中說到最佳解答是使用EXISTS，如此一來就不會執行排序。\n\n```sql\n    SELECT item_no FROM Items I WHERE EXISTS(\n        SELECT * FROM SalesHistory SH WHERE I.item_no = SH.item_no\n    );\n```\n\n## 於極值函數(MAX/MIN)使用索引值\n\nSQL內建MAX跟MIN函數，使用時都會進行排序，但如果參數欄位已有索引值，就只需要掃描到該索引值，不需要搜尋整張表。\n\n```sql\n   這段會需要搜尋整張表格\n    SELECT MAX(item) FROM Items\n```\n\n```sql\n   這段可以使用到索引值\n    SELECT MAX(item_no) FROM Items\n```\n\n由於item_no主鍵的索引值，所以效果更好，即時是複合索引值，只要有首欄位就能使用。雖然這種做法無法真的不排序，但至少可讓前半段搜尋變快，也能提高效率。\n\n## 寫在WHERE的條件不寫在HAVING上\n\n```sql\n    SELECT sale_date, SUM(quantity)\n    FROM SalesHistory \n    GROUP BY sale_date HAVING sale_date = '2007-10-01';\n```\n\n```sql\n    SELECT sale_date, SUM(quantity)\n    FROM SalesHistory WHERE sale_date = '2007-10-01'\n    GROUP BY sale_date;\n```\n\n結果\n\n| sale_date | sum(quantity)|\n| --------- | -----\n| 2007-10-01 | 17 |\n\n從效能來看一定是後者，原因是第一個使用GROUP BY之後彙整進行排序與運算，所以減少列數，才能減輕排序時負擔。第二個就是WHERE條件可使用索引值。某種意義上，sale_date應該是基數非常高的欄位，所以只要有索引值，應該就能讓列數有效率減少。\n\n#### GROUP BY 以及 ORDER BY使用索引值\n\n這兩種方式雖然會執行排序，但只要在欄位上加上索引值，就能讓搜尋速度變快，尤其是UNIQUE索引值欄位，有些系統的規格更是能跳過排序。\n\n\n## 索引值真的派得上用場嗎?\n\n一般來說資料表有一定規模後，通常就會有索引值。把索引值想像成C語言的指標陣列，意思就是比起搜尋規模較大的物件，搜尋較小的指標會更有效率。\n\n    1.不是索引越多越好，索引可以加快查詢速度，但注意它是以空間換取時間。\n    \n    2.懂的使用Explain來分析你的SQL索引性能解析，https://segmentfault.com/a/1190000008131735。\n\n    3.索引不是建了就會使用。SELECT * FROM user WHERE sex = 0 ( 0 代表女生 )，答案是不一定，如果大部份的值都是女生，那 mysql 會用全掃，如果大部份值為男生，那 mysql 會用索引。\n\n    4.連合索引的欄位順序，通常是由最左邊的欄位的才能使用。\n    \n    5.儘可能使用索引的排序。\n\n    6.有時太多索引，反而會讓優化器混亂。\n\n#### 加工索引值欄位\n\n```sql\n   // NO\n   SELECT * FROM SomeTable WHERE col_1 * 1.1 > 100;\n\n   // OK\n   SELECT * FROM SomeTable WHERE col_1 > 100 / 1.1\n```\n\n若於搜尋條件右側使用公式，就會用到索引值。因此可以改成下列方式。同樣的在左側使用函數就無法使用到索引值。\n\n```sql\n   SELECT * FROM SomeTable WHERE SUBSTR(col_1, 1, 1) = 'a';\n```\n\n如果非要左邊進行運算，書中說到可以用函數索引，但這種方式很麻煩也不太建議。\n\n     使用索引值時候，欄位最好是乾淨的。\n\n#### 索引值欄位有NULL\n\n索引值有NULL是很難處理的，而且不同規格有不同處理的方式，這也是因為受到使用者使用IS NULL或是IS NOT NULL，\n就無法使用索引值，或是NULL偏多的欄位無法使用索引的限制導致\b。此外該如何與IS NOT NULL同等條件使用索引值，可以使用下列方式\n\n```sql\n   IS NOT NULL 替代方案\n   SELECT * FROM SomeTable WHERE col_1 > 0;\n```\n\n#### 使用否定型的情況\n\n列出否定型不會使用索引值\n* <>\n* !=\n* NOT IN\n\n因此下列程式也無法取使用索引值。\n\n```sql\n   SELECT * FROM SomeTable WHERE col_1 <> 100;\n```\n\n#### 使用OR的情況\n\n假設col_1與col_2各有索引值情況，或者col_1,col_2有複合索引，使OR撰寫連結條件，就無法使用索引值，而且就算可以使用，搜尋效率也會比AND差。\n\n```sql\n   SELECT * FROM SomeTable WHERE col_1 > 1 OR col_2 = 'abc';\n```\n\n#### 再複合索引下，欄位順序是錯誤的\n\n假設以(col_1,col_2,col_3)這個順序下建立索引值，建立索引值欄位順序就相對重要。\n\n```sql\n   O SELECT * FROM SomeTable WHERE col_1 ＝ 10 AND col_2 = 100 AND col_3 = 500;\n   O SELECT * FROM SomeTable WHERE col_1 ＝ 10 AND col_2 = 100;\n   X SELECT * FROM SomeTable WHERE col_1 ＝ 10 AND col_3 = 500;\n   X SELECT * FROM SomeTable WHERE col_2 ＝ 100 AND col_3 = 500;\n```\n\n第一個欄位一定寫在開頭，順序不能錯亂。某些DB雖然可能順序錯誤情況也可以使用索引值，但是效能還是比順序正確時來得低。\n\n#### 使用後方一致或中間一致的LIKE\n\n```sql\n   X SELECT * FROM SomeTable WHERE col_1 LIKE '%10' ;\n   X SELECT * FROM SomeTable WHERE col_1 LIKE '%10%' ;\n   O SELECT * FROM SomeTable WHERE col_1 LIKE '10%' ;\n```\n\n#### 會進行預設型態轉換\n\n下列是對字串類型的col_1設定條件的情況。\n\n```sql\n   X SELECT * FROM SomeTable WHERE col_1 = 10 ;\n   O SELECT * FROM SomeTable WHERE col_1 = '10' ;\n   O SELECT * FROM SomeTable WHERE col_1 = CAST(10,AS CHAR(2));\n```\n\n## 減少中介資料表\n\nSQL會將子查詢結果為新的資料表，也能在程式碼裡，像是操作原始資料表一般操作。這種高正交性讓SQL程式碼更加靈活，但若是大量使用中介資料也會造成性能下滑，所以盡可能減少中介資料。\n\n```sql\n   SELECT * FROM(\n        SELECT sale_date, MAX(quantity) AS max_qty FROM SalesHistory GROUP BY sale_date\n   ) TMP  <-多餘的中介資料\n   WHERE max_qty >= 10;\n```\n\n不過，要將彙整的結果設定條件，是不需要建立多餘中介資料，只需要使用下列HAVING陳述句。\n\n```sql\n    SELECT sale_date, MAX(quantity) AS max_qty FROM SalesHistory GROUP BY sale_date HAVING MAX(quantity) >= 10;\n```\nHAVING會一邊執行，一邊進行彙整，所以會比建立中介資料表之後才執行WHERE更有效率，且可讀性比較好。\n\n## 利用IN使用多個KEY時，將KEY整理在同一個位置\n\n自從SQL-92之後，就內建許多列間比較的功能，所以=、<、>這類比較或IN的參數不僅可以是純量，還能是LIST。讓我們想想下列這種使用多個Key組成IN內容情況。\n\n```sql\n  SELECT id, state, city FROM Address1 A1 \n  WHERE \n  status IN(\n      SELECT status FROM Address2 A2 WHERE A1.id = A2.id      \n  ) AND city IN (\n      SELECT city FROM Address2 A2 WHERE A1.id = A2.id      \n  )\n```\n\n```sql\n  SELECT * FROM Address1 A1 WHERE id || status || city IN(\n      SELECT id || state || city FROM Address1 A2);\n  )\n```\n\n如此一來既可將子查詢寫成非關聯式類型，還能將搜尋減少為一次，如果是支援列間比較DB，還能如下在IN的參數設定欄位組合。\n\n```sql\n  SELECT * FROM Address1 A1 WHERE (id, status, city) IN(\n      SELECT id , state , city FROM Address1 A2);\n  )\n```\n\n相較於合併字串，這個方法有兩個優點。其一是不用擔心連結的類型轉換，另一個需要加工欄位，所以可使用索引值。\n\n\n## 先連結在彙整\n\n當需要連結使用，盡可能先連結在彙整，才能省去建立中介資料的步驟。之所以能夠省略，全在於集合運算的連結屬於乘法，若具一對一或是一對多的關聯性\n，列數不會在連結之際增加。\n\n## 計畫性地使用視圖\n\n視圖是非常方便的工具，但如果隨便訂了複雜的視圖將使效能下降，尤其定義是圖的查詢含有下列運算時，SQL的效率將變得更差，執行速度也會出乎意料的下滑。\n\n#### 總結\n\n    1.在IN使用子查詢，可以利用EXISTS或改寫連結。\n    2.使用索引值，基本上左邊是空白的。\n    3.SQＬ雖然不需要明定排序部分，但有許多運算會偷偷執行排序，需多加留意。\n    4.盡可能減少不需要的中介資料。\n    5.趁早撰寫能減少紀錄筆數的條件。\n\n參考資料: \n\n1.SQL 達人的工作現場攻略筆\n\n2.https://ithelp.ithome.com.tw/articles/10221971","source":"_posts/sql/202012132016.md","raw":"---\ntitle: SQL 達人的工作現場攻略筆記 - CH-11 要讓SQL加速囉\ndate: 2020-12-23 20:16:00\ntype: \"tags\"\ncategories: 資料庫\ntags: 資料庫\n---\n\n## 前言\n\nSQL 的效能一直是 DB 工程師必須面對的主要課程之一，甚至有些人認為是唯一的課題。此章節是改善 SQL 的效能，讓執行速度更快減少更多資源。\n\n## 使用效率的搜尋\n\n#### 若子查詢為參數\n\n使用(EXISTS)代替(IN)，在 IN 述詞很方便，也很好讀，但卻會遇到效能瓶頸的問題，若當 IN 參數(1,2,3)這種 List 時繼就不需要改寫，但如果以子查詢為參數就必須要注意，通常 NOT IN 跟 NOT EXISTS 都是回傳相同的結果，但是使用 EXISTS 建立子查詢卻快的很多。\n\nClass_A\n\n| id(識別子) |name (姓名) |\n| ----------| ------------ |\n| 1 | 郁 |\n| 2 | 瑋 |\n| 3 | 銘 |\n\nClass_B\n\n| id(識別子) | name(姓名) |\n| --------- | ------------ |\n| 1 | 郁 |\n| 2 | 瑋 |\n| 4 | 靚 |\n\n試著從 Class_A 表找出 Class_B 資料表也有的學生。\n\n```sql\n    較慢\n    SELECT * FROM Class_A WHERE id IN ( SELECT id FROM Class_B);\n```\n\n```sql\n    較快\n    SELECT * FROM Class_A A WHERE EXISTS ( SELECT id FROM Class_B B WHERE A.id = B.id );\n```\n\n結果\n\n| id(識別子) | name(姓名) |\n| --------- | ------------ |\n| 1 | 郁 |\n| 2 | 瑋 |\n\n```\n為什麼EXISTS會比較快？大致上有兩個理由。\n1.如果連結key帶有索引值，就可能直接按照索引值，不需觀察Class_B的資料表。\n2.EXISTS只要找到一筆符合的列，就會立刻停止搜尋，不會是IN得全面搜尋一遍。\n```\n\n#### 子查詢為參數時，使用連結代替 IN\n\n要改善 IN 的效能，除了使用 EXISTS 改寫，也可以利用連結方式去實現。\n\n```sql\n    SELECT Ａ.id,A.name FROM Class_A A INNER JOIN Class_B B ON A.id = B.id;\n```\n\n## 避開排序\n\nSQL 與程式語言不同，使用者無法直接命令 DBMS 指定排序運算，不過這不代表 DBMS 不執行排序，更精準的說是 DBMS 非常頻繁的偷偷執行排序，也導致使用者不用去理會哪中運算正在執行排序。\n\n會執行排序如下 :\n\n    1.GROUP BY\n    2.ORDER BY\n    3.彙總函數(SUM、COUNT、AVG、MAX、MIN)\n    4.DISTINCT\n    5.UNION、INTERSECT、EXCEPT\n    6.視窗函數(RANK ROW_NUMBER)\n\n#### 善用集合運算的 ALL 選項\n\nSQL具有UNION、INTERSECT、EXCEPT 三種集合運算子，如果直接使用一定會為了排除重複資料而執行排序。\n\n```sql\n    SELECT * FROM Class_A\n     UNION\n    SELECT * FROM Class_B;\n```\n\n結果\n\n| id(識別子) | name(姓名) |\n| --------- | ------------ |\n| 1 | 郁 |\n| 2 | 瑋 |\n| 3 | 銘 |\n| 4 | 靚 |\n\n如果不用在乎重複資料或事先知道不會有重複資料，可以利用 UNION ALL 代替，避免執行排序。\n\n#### 以 EXISTS 代替 DISTINCT\n\nDISTINCT 也會為了排除重複資料而執行排序。若是為了統整兩張表連結結果而使用 DISTINCT 的情況，也可以使用 EXISTS 代替，也能避免執行排序。\n\nItems\n\n| item_no|item |\n| ----------| ------------ |\n| 10| SD 記憶卡 |\n| 20 | CD-R |\n| 30 | USB 隨身碟|\n| 40 | DVD|\n\nSalesHistory\n\n| sale_date | item_no | quantity |\n| --------- | ------------ | ------------ |\n| 2020-10-01 | 10 | 4 |\n| 2020-10-01 | 20 | 10 |\n| 2020-10-01 | 30 | 3 |\n| 2020-10-03 | 10 | 32 |\n| 2020-10-03 | 30 | 12 |\n| 2020-10-04 | 20 | 22 |\n| 2020-10-04 | 30 | 7 |\n\n根據上方商品主資料表選出業績表的商品，簡單說就是找出有業績的商品，此時書中說使用IN雖然不錯。但前面提到用連結會更好。\n\n```sql\n    SELECT I.item_no FROM Items I INNER JOIN SalesHistory SH ON I.item_no = SH.item_no;\n```\n\n結果\n\n| item_no |\n| --------- |\n| 10|\n| 10|\n| 20|\n| 20|\n| 30|\n| 30|\n| 30|\n\n由於是一對多連結，就會出現重複資料，若要將重複資料排除勢必使用DISTINCT那這樣就會執行到排序，所以書中說到最佳解答是使用EXISTS，如此一來就不會執行排序。\n\n```sql\n    SELECT item_no FROM Items I WHERE EXISTS(\n        SELECT * FROM SalesHistory SH WHERE I.item_no = SH.item_no\n    );\n```\n\n## 於極值函數(MAX/MIN)使用索引值\n\nSQL內建MAX跟MIN函數，使用時都會進行排序，但如果參數欄位已有索引值，就只需要掃描到該索引值，不需要搜尋整張表。\n\n```sql\n   這段會需要搜尋整張表格\n    SELECT MAX(item) FROM Items\n```\n\n```sql\n   這段可以使用到索引值\n    SELECT MAX(item_no) FROM Items\n```\n\n由於item_no主鍵的索引值，所以效果更好，即時是複合索引值，只要有首欄位就能使用。雖然這種做法無法真的不排序，但至少可讓前半段搜尋變快，也能提高效率。\n\n## 寫在WHERE的條件不寫在HAVING上\n\n```sql\n    SELECT sale_date, SUM(quantity)\n    FROM SalesHistory \n    GROUP BY sale_date HAVING sale_date = '2007-10-01';\n```\n\n```sql\n    SELECT sale_date, SUM(quantity)\n    FROM SalesHistory WHERE sale_date = '2007-10-01'\n    GROUP BY sale_date;\n```\n\n結果\n\n| sale_date | sum(quantity)|\n| --------- | -----\n| 2007-10-01 | 17 |\n\n從效能來看一定是後者，原因是第一個使用GROUP BY之後彙整進行排序與運算，所以減少列數，才能減輕排序時負擔。第二個就是WHERE條件可使用索引值。某種意義上，sale_date應該是基數非常高的欄位，所以只要有索引值，應該就能讓列數有效率減少。\n\n#### GROUP BY 以及 ORDER BY使用索引值\n\n這兩種方式雖然會執行排序，但只要在欄位上加上索引值，就能讓搜尋速度變快，尤其是UNIQUE索引值欄位，有些系統的規格更是能跳過排序。\n\n\n## 索引值真的派得上用場嗎?\n\n一般來說資料表有一定規模後，通常就會有索引值。把索引值想像成C語言的指標陣列，意思就是比起搜尋規模較大的物件，搜尋較小的指標會更有效率。\n\n    1.不是索引越多越好，索引可以加快查詢速度，但注意它是以空間換取時間。\n    \n    2.懂的使用Explain來分析你的SQL索引性能解析，https://segmentfault.com/a/1190000008131735。\n\n    3.索引不是建了就會使用。SELECT * FROM user WHERE sex = 0 ( 0 代表女生 )，答案是不一定，如果大部份的值都是女生，那 mysql 會用全掃，如果大部份值為男生，那 mysql 會用索引。\n\n    4.連合索引的欄位順序，通常是由最左邊的欄位的才能使用。\n    \n    5.儘可能使用索引的排序。\n\n    6.有時太多索引，反而會讓優化器混亂。\n\n#### 加工索引值欄位\n\n```sql\n   // NO\n   SELECT * FROM SomeTable WHERE col_1 * 1.1 > 100;\n\n   // OK\n   SELECT * FROM SomeTable WHERE col_1 > 100 / 1.1\n```\n\n若於搜尋條件右側使用公式，就會用到索引值。因此可以改成下列方式。同樣的在左側使用函數就無法使用到索引值。\n\n```sql\n   SELECT * FROM SomeTable WHERE SUBSTR(col_1, 1, 1) = 'a';\n```\n\n如果非要左邊進行運算，書中說到可以用函數索引，但這種方式很麻煩也不太建議。\n\n     使用索引值時候，欄位最好是乾淨的。\n\n#### 索引值欄位有NULL\n\n索引值有NULL是很難處理的，而且不同規格有不同處理的方式，這也是因為受到使用者使用IS NULL或是IS NOT NULL，\n就無法使用索引值，或是NULL偏多的欄位無法使用索引的限制導致\b。此外該如何與IS NOT NULL同等條件使用索引值，可以使用下列方式\n\n```sql\n   IS NOT NULL 替代方案\n   SELECT * FROM SomeTable WHERE col_1 > 0;\n```\n\n#### 使用否定型的情況\n\n列出否定型不會使用索引值\n* <>\n* !=\n* NOT IN\n\n因此下列程式也無法取使用索引值。\n\n```sql\n   SELECT * FROM SomeTable WHERE col_1 <> 100;\n```\n\n#### 使用OR的情況\n\n假設col_1與col_2各有索引值情況，或者col_1,col_2有複合索引，使OR撰寫連結條件，就無法使用索引值，而且就算可以使用，搜尋效率也會比AND差。\n\n```sql\n   SELECT * FROM SomeTable WHERE col_1 > 1 OR col_2 = 'abc';\n```\n\n#### 再複合索引下，欄位順序是錯誤的\n\n假設以(col_1,col_2,col_3)這個順序下建立索引值，建立索引值欄位順序就相對重要。\n\n```sql\n   O SELECT * FROM SomeTable WHERE col_1 ＝ 10 AND col_2 = 100 AND col_3 = 500;\n   O SELECT * FROM SomeTable WHERE col_1 ＝ 10 AND col_2 = 100;\n   X SELECT * FROM SomeTable WHERE col_1 ＝ 10 AND col_3 = 500;\n   X SELECT * FROM SomeTable WHERE col_2 ＝ 100 AND col_3 = 500;\n```\n\n第一個欄位一定寫在開頭，順序不能錯亂。某些DB雖然可能順序錯誤情況也可以使用索引值，但是效能還是比順序正確時來得低。\n\n#### 使用後方一致或中間一致的LIKE\n\n```sql\n   X SELECT * FROM SomeTable WHERE col_1 LIKE '%10' ;\n   X SELECT * FROM SomeTable WHERE col_1 LIKE '%10%' ;\n   O SELECT * FROM SomeTable WHERE col_1 LIKE '10%' ;\n```\n\n#### 會進行預設型態轉換\n\n下列是對字串類型的col_1設定條件的情況。\n\n```sql\n   X SELECT * FROM SomeTable WHERE col_1 = 10 ;\n   O SELECT * FROM SomeTable WHERE col_1 = '10' ;\n   O SELECT * FROM SomeTable WHERE col_1 = CAST(10,AS CHAR(2));\n```\n\n## 減少中介資料表\n\nSQL會將子查詢結果為新的資料表，也能在程式碼裡，像是操作原始資料表一般操作。這種高正交性讓SQL程式碼更加靈活，但若是大量使用中介資料也會造成性能下滑，所以盡可能減少中介資料。\n\n```sql\n   SELECT * FROM(\n        SELECT sale_date, MAX(quantity) AS max_qty FROM SalesHistory GROUP BY sale_date\n   ) TMP  <-多餘的中介資料\n   WHERE max_qty >= 10;\n```\n\n不過，要將彙整的結果設定條件，是不需要建立多餘中介資料，只需要使用下列HAVING陳述句。\n\n```sql\n    SELECT sale_date, MAX(quantity) AS max_qty FROM SalesHistory GROUP BY sale_date HAVING MAX(quantity) >= 10;\n```\nHAVING會一邊執行，一邊進行彙整，所以會比建立中介資料表之後才執行WHERE更有效率，且可讀性比較好。\n\n## 利用IN使用多個KEY時，將KEY整理在同一個位置\n\n自從SQL-92之後，就內建許多列間比較的功能，所以=、<、>這類比較或IN的參數不僅可以是純量，還能是LIST。讓我們想想下列這種使用多個Key組成IN內容情況。\n\n```sql\n  SELECT id, state, city FROM Address1 A1 \n  WHERE \n  status IN(\n      SELECT status FROM Address2 A2 WHERE A1.id = A2.id      \n  ) AND city IN (\n      SELECT city FROM Address2 A2 WHERE A1.id = A2.id      \n  )\n```\n\n```sql\n  SELECT * FROM Address1 A1 WHERE id || status || city IN(\n      SELECT id || state || city FROM Address1 A2);\n  )\n```\n\n如此一來既可將子查詢寫成非關聯式類型，還能將搜尋減少為一次，如果是支援列間比較DB，還能如下在IN的參數設定欄位組合。\n\n```sql\n  SELECT * FROM Address1 A1 WHERE (id, status, city) IN(\n      SELECT id , state , city FROM Address1 A2);\n  )\n```\n\n相較於合併字串，這個方法有兩個優點。其一是不用擔心連結的類型轉換，另一個需要加工欄位，所以可使用索引值。\n\n\n## 先連結在彙整\n\n當需要連結使用，盡可能先連結在彙整，才能省去建立中介資料的步驟。之所以能夠省略，全在於集合運算的連結屬於乘法，若具一對一或是一對多的關聯性\n，列數不會在連結之際增加。\n\n## 計畫性地使用視圖\n\n視圖是非常方便的工具，但如果隨便訂了複雜的視圖將使效能下降，尤其定義是圖的查詢含有下列運算時，SQL的效率將變得更差，執行速度也會出乎意料的下滑。\n\n#### 總結\n\n    1.在IN使用子查詢，可以利用EXISTS或改寫連結。\n    2.使用索引值，基本上左邊是空白的。\n    3.SQＬ雖然不需要明定排序部分，但有許多運算會偷偷執行排序，需多加留意。\n    4.盡可能減少不需要的中介資料。\n    5.趁早撰寫能減少紀錄筆數的條件。\n\n參考資料: \n\n1.SQL 達人的工作現場攻略筆\n\n2.https://ithelp.ithome.com.tw/articles/10221971","slug":"sql/202012132016","published":1,"updated":"2022-03-16T13:14:46.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0tlcc680007fx7r3og41u1v","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>SQL 的效能一直是 DB 工程師必須面對的主要課程之一，甚至有些人認為是唯一的課題。此章節是改善 SQL 的效能，讓執行速度更快減少更多資源。</p>\n<h2 id=\"使用效率的搜尋\"><a href=\"#使用效率的搜尋\" class=\"headerlink\" title=\"使用效率的搜尋\"></a>使用效率的搜尋</h2><h4 id=\"若子查詢為參數\"><a href=\"#若子查詢為參數\" class=\"headerlink\" title=\"若子查詢為參數\"></a>若子查詢為參數</h4><p>使用(EXISTS)代替(IN)，在 IN 述詞很方便，也很好讀，但卻會遇到效能瓶頸的問題，若當 IN 參數(1,2,3)這種 List 時繼就不需要改寫，但如果以子查詢為參數就必須要注意，通常 NOT IN 跟 NOT EXISTS 都是回傳相同的結果，但是使用 EXISTS 建立子查詢卻快的很多。</p>\n<p>Class_A</p>\n<table>\n<thead>\n<tr>\n<th>id(識別子)</th>\n<th>name (姓名)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>郁</td>\n</tr>\n<tr>\n<td>2</td>\n<td>瑋</td>\n</tr>\n<tr>\n<td>3</td>\n<td>銘</td>\n</tr>\n</tbody></table>\n<p>Class_B</p>\n<table>\n<thead>\n<tr>\n<th>id(識別子)</th>\n<th>name(姓名)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>郁</td>\n</tr>\n<tr>\n<td>2</td>\n<td>瑋</td>\n</tr>\n<tr>\n<td>4</td>\n<td>靚</td>\n</tr>\n</tbody></table>\n<p>試著從 Class_A 表找出 Class_B 資料表也有的學生。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">較慢</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Class_A <span class=\"keyword\">WHERE</span> <span class=\"keyword\">id</span> <span class=\"keyword\">IN</span> ( <span class=\"keyword\">SELECT</span> <span class=\"keyword\">id</span> <span class=\"keyword\">FROM</span> Class_B);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">較快</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Class_A A <span class=\"keyword\">WHERE</span> <span class=\"keyword\">EXISTS</span> ( <span class=\"keyword\">SELECT</span> <span class=\"keyword\">id</span> <span class=\"keyword\">FROM</span> Class_B B <span class=\"keyword\">WHERE</span> A.id = B.id );</span><br></pre></td></tr></table></figure>\n\n<p>結果</p>\n<table>\n<thead>\n<tr>\n<th>id(識別子)</th>\n<th>name(姓名)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>郁</td>\n</tr>\n<tr>\n<td>2</td>\n<td>瑋</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">為什麼EXISTS會比較快？大致上有兩個理由。</span><br><span class=\"line\">1.如果連結key帶有索引值，就可能直接按照索引值，不需觀察Class_B的資料表。</span><br><span class=\"line\">2.EXISTS只要找到一筆符合的列，就會立刻停止搜尋，不會是IN得全面搜尋一遍。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"子查詢為參數時，使用連結代替-IN\"><a href=\"#子查詢為參數時，使用連結代替-IN\" class=\"headerlink\" title=\"子查詢為參數時，使用連結代替 IN\"></a>子查詢為參數時，使用連結代替 IN</h4><p>要改善 IN 的效能，除了使用 EXISTS 改寫，也可以利用連結方式去實現。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> Ａ.id,A.name <span class=\"keyword\">FROM</span> Class_A A <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Class_B B <span class=\"keyword\">ON</span> A.id = B.id;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"避開排序\"><a href=\"#避開排序\" class=\"headerlink\" title=\"避開排序\"></a>避開排序</h2><p>SQL 與程式語言不同，使用者無法直接命令 DBMS 指定排序運算，不過這不代表 DBMS 不執行排序，更精準的說是 DBMS 非常頻繁的偷偷執行排序，也導致使用者不用去理會哪中運算正在執行排序。</p>\n<p>會執行排序如下 :</p>\n<pre><code>1.GROUP BY\n2.ORDER BY\n3.彙總函數(SUM、COUNT、AVG、MAX、MIN)\n4.DISTINCT\n5.UNION、INTERSECT、EXCEPT\n6.視窗函數(RANK ROW_NUMBER)</code></pre>\n<h4 id=\"善用集合運算的-ALL-選項\"><a href=\"#善用集合運算的-ALL-選項\" class=\"headerlink\" title=\"善用集合運算的 ALL 選項\"></a>善用集合運算的 ALL 選項</h4><p>SQL具有UNION、INTERSECT、EXCEPT 三種集合運算子，如果直接使用一定會為了排除重複資料而執行排序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Class_A</span><br><span class=\"line\"> <span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Class_B;</span><br></pre></td></tr></table></figure>\n\n<p>結果</p>\n<table>\n<thead>\n<tr>\n<th>id(識別子)</th>\n<th>name(姓名)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>郁</td>\n</tr>\n<tr>\n<td>2</td>\n<td>瑋</td>\n</tr>\n<tr>\n<td>3</td>\n<td>銘</td>\n</tr>\n<tr>\n<td>4</td>\n<td>靚</td>\n</tr>\n</tbody></table>\n<p>如果不用在乎重複資料或事先知道不會有重複資料，可以利用 UNION ALL 代替，避免執行排序。</p>\n<h4 id=\"以-EXISTS-代替-DISTINCT\"><a href=\"#以-EXISTS-代替-DISTINCT\" class=\"headerlink\" title=\"以 EXISTS 代替 DISTINCT\"></a>以 EXISTS 代替 DISTINCT</h4><p>DISTINCT 也會為了排除重複資料而執行排序。若是為了統整兩張表連結結果而使用 DISTINCT 的情況，也可以使用 EXISTS 代替，也能避免執行排序。</p>\n<p>Items</p>\n<table>\n<thead>\n<tr>\n<th>item_no</th>\n<th>item</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10</td>\n<td>SD 記憶卡</td>\n</tr>\n<tr>\n<td>20</td>\n<td>CD-R</td>\n</tr>\n<tr>\n<td>30</td>\n<td>USB 隨身碟</td>\n</tr>\n<tr>\n<td>40</td>\n<td>DVD</td>\n</tr>\n</tbody></table>\n<p>SalesHistory</p>\n<table>\n<thead>\n<tr>\n<th>sale_date</th>\n<th>item_no</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2020-10-01</td>\n<td>10</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2020-10-01</td>\n<td>20</td>\n<td>10</td>\n</tr>\n<tr>\n<td>2020-10-01</td>\n<td>30</td>\n<td>3</td>\n</tr>\n<tr>\n<td>2020-10-03</td>\n<td>10</td>\n<td>32</td>\n</tr>\n<tr>\n<td>2020-10-03</td>\n<td>30</td>\n<td>12</td>\n</tr>\n<tr>\n<td>2020-10-04</td>\n<td>20</td>\n<td>22</td>\n</tr>\n<tr>\n<td>2020-10-04</td>\n<td>30</td>\n<td>7</td>\n</tr>\n</tbody></table>\n<p>根據上方商品主資料表選出業績表的商品，簡單說就是找出有業績的商品，此時書中說使用IN雖然不錯。但前面提到用連結會更好。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> I.item_no <span class=\"keyword\">FROM</span> Items I <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> SalesHistory SH <span class=\"keyword\">ON</span> I.item_no = SH.item_no;</span><br></pre></td></tr></table></figure>\n\n<p>結果</p>\n<table>\n<thead>\n<tr>\n<th>item_no</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10</td>\n</tr>\n<tr>\n<td>10</td>\n</tr>\n<tr>\n<td>20</td>\n</tr>\n<tr>\n<td>20</td>\n</tr>\n<tr>\n<td>30</td>\n</tr>\n<tr>\n<td>30</td>\n</tr>\n<tr>\n<td>30</td>\n</tr>\n</tbody></table>\n<p>由於是一對多連結，就會出現重複資料，若要將重複資料排除勢必使用DISTINCT那這樣就會執行到排序，所以書中說到最佳解答是使用EXISTS，如此一來就不會執行排序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> item_no <span class=\"keyword\">FROM</span> Items I <span class=\"keyword\">WHERE</span> <span class=\"keyword\">EXISTS</span>(</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SalesHistory SH <span class=\"keyword\">WHERE</span> I.item_no = SH.item_no</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"於極值函數-MAX-MIN-使用索引值\"><a href=\"#於極值函數-MAX-MIN-使用索引值\" class=\"headerlink\" title=\"於極值函數(MAX/MIN)使用索引值\"></a>於極值函數(MAX/MIN)使用索引值</h2><p>SQL內建MAX跟MIN函數，使用時都會進行排序，但如果參數欄位已有索引值，就只需要掃描到該索引值，不需要搜尋整張表。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">這段會需要搜尋整張表格</span><br><span class=\"line\"> <span class=\"keyword\">SELECT</span> <span class=\"keyword\">MAX</span>(item) <span class=\"keyword\">FROM</span> Items</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">這段可以使用到索引值</span><br><span class=\"line\"> <span class=\"keyword\">SELECT</span> <span class=\"keyword\">MAX</span>(item_no) <span class=\"keyword\">FROM</span> Items</span><br></pre></td></tr></table></figure>\n\n<p>由於item_no主鍵的索引值，所以效果更好，即時是複合索引值，只要有首欄位就能使用。雖然這種做法無法真的不排序，但至少可讓前半段搜尋變快，也能提高效率。</p>\n<h2 id=\"寫在WHERE的條件不寫在HAVING上\"><a href=\"#寫在WHERE的條件不寫在HAVING上\" class=\"headerlink\" title=\"寫在WHERE的條件不寫在HAVING上\"></a>寫在WHERE的條件不寫在HAVING上</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> sale_date, <span class=\"keyword\">SUM</span>(quantity)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> SalesHistory </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sale_date <span class=\"keyword\">HAVING</span> sale_date = <span class=\"string\">&#x27;2007-10-01&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> sale_date, <span class=\"keyword\">SUM</span>(quantity)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> SalesHistory <span class=\"keyword\">WHERE</span> sale_date = <span class=\"string\">&#x27;2007-10-01&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sale_date;</span><br></pre></td></tr></table></figure>\n\n<p>結果</p>\n<table>\n<thead>\n<tr>\n<th>sale_date</th>\n<th>sum(quantity)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2007-10-01</td>\n<td>17</td>\n</tr>\n</tbody></table>\n<p>從效能來看一定是後者，原因是第一個使用GROUP BY之後彙整進行排序與運算，所以減少列數，才能減輕排序時負擔。第二個就是WHERE條件可使用索引值。某種意義上，sale_date應該是基數非常高的欄位，所以只要有索引值，應該就能讓列數有效率減少。</p>\n<h4 id=\"GROUP-BY-以及-ORDER-BY使用索引值\"><a href=\"#GROUP-BY-以及-ORDER-BY使用索引值\" class=\"headerlink\" title=\"GROUP BY 以及 ORDER BY使用索引值\"></a>GROUP BY 以及 ORDER BY使用索引值</h4><p>這兩種方式雖然會執行排序，但只要在欄位上加上索引值，就能讓搜尋速度變快，尤其是UNIQUE索引值欄位，有些系統的規格更是能跳過排序。</p>\n<h2 id=\"索引值真的派得上用場嗎\"><a href=\"#索引值真的派得上用場嗎\" class=\"headerlink\" title=\"索引值真的派得上用場嗎?\"></a>索引值真的派得上用場嗎?</h2><p>一般來說資料表有一定規模後，通常就會有索引值。把索引值想像成C語言的指標陣列，意思就是比起搜尋規模較大的物件，搜尋較小的指標會更有效率。</p>\n<pre><code>1.不是索引越多越好，索引可以加快查詢速度，但注意它是以空間換取時間。\n\n2.懂的使用Explain來分析你的SQL索引性能解析，https://segmentfault.com/a/1190000008131735。\n\n3.索引不是建了就會使用。SELECT * FROM user WHERE sex = 0 ( 0 代表女生 )，答案是不一定，如果大部份的值都是女生，那 mysql 會用全掃，如果大部份值為男生，那 mysql 會用索引。\n\n4.連合索引的欄位順序，通常是由最左邊的欄位的才能使用。\n\n5.儘可能使用索引的排序。\n\n6.有時太多索引，反而會讓優化器混亂。</code></pre>\n<h4 id=\"加工索引值欄位\"><a href=\"#加工索引值欄位\" class=\"headerlink\" title=\"加工索引值欄位\"></a>加工索引值欄位</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// NO</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 * <span class=\"number\">1.1</span> &gt; <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">// OK</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 &gt; <span class=\"number\">100</span> / <span class=\"number\">1.1</span></span><br></pre></td></tr></table></figure>\n\n<p>若於搜尋條件右側使用公式，就會用到索引值。因此可以改成下列方式。同樣的在左側使用函數就無法使用到索引值。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> <span class=\"keyword\">SUBSTR</span>(col_1, <span class=\"number\">1</span>, <span class=\"number\">1</span>) = <span class=\"string\">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果非要左邊進行運算，書中說到可以用函數索引，但這種方式很麻煩也不太建議。</p>\n<pre><code> 使用索引值時候，欄位最好是乾淨的。</code></pre>\n<h4 id=\"索引值欄位有NULL\"><a href=\"#索引值欄位有NULL\" class=\"headerlink\" title=\"索引值欄位有NULL\"></a>索引值欄位有NULL</h4><p>索引值有NULL是很難處理的，而且不同規格有不同處理的方式，這也是因為受到使用者使用IS NULL或是IS NOT NULL，<br>就無法使用索引值，或是NULL偏多的欄位無法使用索引的限制導致\b。此外該如何與IS NOT NULL同等條件使用索引值，可以使用下列方式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IS NOT NULL 替代方案</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 &gt; <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用否定型的情況\"><a href=\"#使用否定型的情況\" class=\"headerlink\" title=\"使用否定型的情況\"></a>使用否定型的情況</h4><p>列出否定型不會使用索引值</p>\n<ul>\n<li>&lt;&gt;</li>\n<li>!=</li>\n<li>NOT IN</li>\n</ul>\n<p>因此下列程式也無法取使用索引值。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 &lt;&gt; <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用OR的情況\"><a href=\"#使用OR的情況\" class=\"headerlink\" title=\"使用OR的情況\"></a>使用OR的情況</h4><p>假設col_1與col_2各有索引值情況，或者col_1,col_2有複合索引，使OR撰寫連結條件，就無法使用索引值，而且就算可以使用，搜尋效率也會比AND差。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 &gt; <span class=\"number\">1</span> <span class=\"keyword\">OR</span> col_2 = <span class=\"string\">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"再複合索引下，欄位順序是錯誤的\"><a href=\"#再複合索引下，欄位順序是錯誤的\" class=\"headerlink\" title=\"再複合索引下，欄位順序是錯誤的\"></a>再複合索引下，欄位順序是錯誤的</h4><p>假設以(col_1,col_2,col_3)這個順序下建立索引值，建立索引值欄位順序就相對重要。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">O <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 ＝ <span class=\"number\">10</span> <span class=\"keyword\">AND</span> col_2 = <span class=\"number\">100</span> <span class=\"keyword\">AND</span> col_3 = <span class=\"number\">500</span>;</span><br><span class=\"line\">O <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 ＝ <span class=\"number\">10</span> <span class=\"keyword\">AND</span> col_2 = <span class=\"number\">100</span>;</span><br><span class=\"line\">X <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 ＝ <span class=\"number\">10</span> <span class=\"keyword\">AND</span> col_3 = <span class=\"number\">500</span>;</span><br><span class=\"line\">X <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_2 ＝ <span class=\"number\">100</span> <span class=\"keyword\">AND</span> col_3 = <span class=\"number\">500</span>;</span><br></pre></td></tr></table></figure>\n\n<p>第一個欄位一定寫在開頭，順序不能錯亂。某些DB雖然可能順序錯誤情況也可以使用索引值，但是效能還是比順序正確時來得低。</p>\n<h4 id=\"使用後方一致或中間一致的LIKE\"><a href=\"#使用後方一致或中間一致的LIKE\" class=\"headerlink\" title=\"使用後方一致或中間一致的LIKE\"></a>使用後方一致或中間一致的LIKE</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%10&#x27;</span> ;</span><br><span class=\"line\">X <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%10%&#x27;</span> ;</span><br><span class=\"line\">O <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;10%&#x27;</span> ;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"會進行預設型態轉換\"><a href=\"#會進行預設型態轉換\" class=\"headerlink\" title=\"會進行預設型態轉換\"></a>會進行預設型態轉換</h4><p>下列是對字串類型的col_1設定條件的情況。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 = <span class=\"number\">10</span> ;</span><br><span class=\"line\">O <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 = <span class=\"string\">&#x27;10&#x27;</span> ;</span><br><span class=\"line\">O <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 = <span class=\"keyword\">CAST</span>(<span class=\"number\">10</span>,<span class=\"keyword\">AS</span> <span class=\"built_in\">CHAR</span>(<span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"減少中介資料表\"><a href=\"#減少中介資料表\" class=\"headerlink\" title=\"減少中介資料表\"></a>減少中介資料表</h2><p>SQL會將子查詢結果為新的資料表，也能在程式碼裡，像是操作原始資料表一般操作。這種高正交性讓SQL程式碼更加靈活，但若是大量使用中介資料也會造成性能下滑，所以盡可能減少中介資料。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span>(</span><br><span class=\"line\">     <span class=\"keyword\">SELECT</span> sale_date, <span class=\"keyword\">MAX</span>(quantity) <span class=\"keyword\">AS</span> max_qty <span class=\"keyword\">FROM</span> SalesHistory <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sale_date</span><br><span class=\"line\">) TMP  &lt;-多餘的中介資料</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> max_qty &gt;= <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<p>不過，要將彙整的結果設定條件，是不需要建立多餘中介資料，只需要使用下列HAVING陳述句。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> sale_date, <span class=\"keyword\">MAX</span>(quantity) <span class=\"keyword\">AS</span> max_qty <span class=\"keyword\">FROM</span> SalesHistory <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sale_date <span class=\"keyword\">HAVING</span> <span class=\"keyword\">MAX</span>(quantity) &gt;= <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>HAVING會一邊執行，一邊進行彙整，所以會比建立中介資料表之後才執行WHERE更有效率，且可讀性比較好。</p>\n<h2 id=\"利用IN使用多個KEY時，將KEY整理在同一個位置\"><a href=\"#利用IN使用多個KEY時，將KEY整理在同一個位置\" class=\"headerlink\" title=\"利用IN使用多個KEY時，將KEY整理在同一個位置\"></a>利用IN使用多個KEY時，將KEY整理在同一個位置</h2><p>自從SQL-92之後，就內建許多列間比較的功能，所以=、&lt;、&gt;這類比較或IN的參數不僅可以是純量，還能是LIST。讓我們想想下列這種使用多個Key組成IN內容情況。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">id</span>, state, city <span class=\"keyword\">FROM</span> Address1 A1 </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> </span><br><span class=\"line\"><span class=\"keyword\">status</span> <span class=\"keyword\">IN</span>(</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> <span class=\"keyword\">status</span> <span class=\"keyword\">FROM</span> Address2 A2 <span class=\"keyword\">WHERE</span> A1.id = A2.id      </span><br><span class=\"line\">) <span class=\"keyword\">AND</span> city <span class=\"keyword\">IN</span> (</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> city <span class=\"keyword\">FROM</span> Address2 A2 <span class=\"keyword\">WHERE</span> A1.id = A2.id      </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Address1 A1 <span class=\"keyword\">WHERE</span> <span class=\"keyword\">id</span> || <span class=\"keyword\">status</span> || city <span class=\"keyword\">IN</span>(</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> <span class=\"keyword\">id</span> || state || city <span class=\"keyword\">FROM</span> Address1 A2);</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>如此一來既可將子查詢寫成非關聯式類型，還能將搜尋減少為一次，如果是支援列間比較DB，還能如下在IN的參數設定欄位組合。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Address1 A1 <span class=\"keyword\">WHERE</span> (<span class=\"keyword\">id</span>, <span class=\"keyword\">status</span>, city) <span class=\"keyword\">IN</span>(</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> <span class=\"keyword\">id</span> , state , city <span class=\"keyword\">FROM</span> Address1 A2);</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>相較於合併字串，這個方法有兩個優點。其一是不用擔心連結的類型轉換，另一個需要加工欄位，所以可使用索引值。</p>\n<h2 id=\"先連結在彙整\"><a href=\"#先連結在彙整\" class=\"headerlink\" title=\"先連結在彙整\"></a>先連結在彙整</h2><p>當需要連結使用，盡可能先連結在彙整，才能省去建立中介資料的步驟。之所以能夠省略，全在於集合運算的連結屬於乘法，若具一對一或是一對多的關聯性<br>，列數不會在連結之際增加。</p>\n<h2 id=\"計畫性地使用視圖\"><a href=\"#計畫性地使用視圖\" class=\"headerlink\" title=\"計畫性地使用視圖\"></a>計畫性地使用視圖</h2><p>視圖是非常方便的工具，但如果隨便訂了複雜的視圖將使效能下降，尤其定義是圖的查詢含有下列運算時，SQL的效率將變得更差，執行速度也會出乎意料的下滑。</p>\n<h4 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h4><pre><code>1.在IN使用子查詢，可以利用EXISTS或改寫連結。\n2.使用索引值，基本上左邊是空白的。\n3.SQＬ雖然不需要明定排序部分，但有許多運算會偷偷執行排序，需多加留意。\n4.盡可能減少不需要的中介資料。\n5.趁早撰寫能減少紀錄筆數的條件。</code></pre>\n<p>參考資料: </p>\n<p>1.SQL 達人的工作現場攻略筆</p>\n<p>2.<a href=\"https://ithelp.ithome.com.tw/articles/10221971\">https://ithelp.ithome.com.tw/articles/10221971</a></p>\n","site":{"data":{"styles":""}},"excerpt":"前言\nSQL 的效能一直是 DB 工程師必須面對的主要課程之一，甚至有些人認為是唯一的課題。此章節是改善 SQL 的效能，讓執行速度更快減少更多資源。\n\n使用效率的搜尋\n若子查詢為參數\n使用(EXISTS)代替(IN)，在 IN 述詞很方便，也很好讀，但卻會遇到效能瓶頸的問題，若當 IN 參數(1,2,3)這種 List 時繼就不需要改寫，但如果以子查詢為參數就必須要注意，通常 NOT IN 跟 NOT EXISTS 都是回傳相同的結果，但是使用 EXISTS 建立子查詢卻快的很多。\n\nClass_A\n\nid(識別子)name (姓名)1郁2瑋3銘Class_B\n\nid(識別子)name(姓名","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>SQL 的效能一直是 DB 工程師必須面對的主要課程之一，甚至有些人認為是唯一的課題。此章節是改善 SQL 的效能，讓執行速度更快減少更多資源。</p>\n<h2 id=\"使用效率的搜尋\"><a href=\"#使用效率的搜尋\" class=\"headerlink\" title=\"使用效率的搜尋\"></a>使用效率的搜尋</h2><h4 id=\"若子查詢為參數\"><a href=\"#若子查詢為參數\" class=\"headerlink\" title=\"若子查詢為參數\"></a>若子查詢為參數</h4><p>使用(EXISTS)代替(IN)，在 IN 述詞很方便，也很好讀，但卻會遇到效能瓶頸的問題，若當 IN 參數(1,2,3)這種 List 時繼就不需要改寫，但如果以子查詢為參數就必須要注意，通常 NOT IN 跟 NOT EXISTS 都是回傳相同的結果，但是使用 EXISTS 建立子查詢卻快的很多。</p>\n<p>Class_A</p>\n<table>\n<thead>\n<tr>\n<th>id(識別子)</th>\n<th>name (姓名)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>郁</td>\n</tr>\n<tr>\n<td>2</td>\n<td>瑋</td>\n</tr>\n<tr>\n<td>3</td>\n<td>銘</td>\n</tr>\n</tbody></table>\n<p>Class_B</p>\n<table>\n<thead>\n<tr>\n<th>id(識別子)</th>\n<th>name(姓名)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>郁</td>\n</tr>\n<tr>\n<td>2</td>\n<td>瑋</td>\n</tr>\n<tr>\n<td>4</td>\n<td>靚</td>\n</tr>\n</tbody></table>\n<p>試著從 Class_A 表找出 Class_B 資料表也有的學生。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">較慢</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Class_A <span class=\"keyword\">WHERE</span> <span class=\"keyword\">id</span> <span class=\"keyword\">IN</span> ( <span class=\"keyword\">SELECT</span> <span class=\"keyword\">id</span> <span class=\"keyword\">FROM</span> Class_B);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">較快</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Class_A A <span class=\"keyword\">WHERE</span> <span class=\"keyword\">EXISTS</span> ( <span class=\"keyword\">SELECT</span> <span class=\"keyword\">id</span> <span class=\"keyword\">FROM</span> Class_B B <span class=\"keyword\">WHERE</span> A.id = B.id );</span><br></pre></td></tr></table></figure>\n\n<p>結果</p>\n<table>\n<thead>\n<tr>\n<th>id(識別子)</th>\n<th>name(姓名)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>郁</td>\n</tr>\n<tr>\n<td>2</td>\n<td>瑋</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">為什麼EXISTS會比較快？大致上有兩個理由。</span><br><span class=\"line\">1.如果連結key帶有索引值，就可能直接按照索引值，不需觀察Class_B的資料表。</span><br><span class=\"line\">2.EXISTS只要找到一筆符合的列，就會立刻停止搜尋，不會是IN得全面搜尋一遍。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"子查詢為參數時，使用連結代替-IN\"><a href=\"#子查詢為參數時，使用連結代替-IN\" class=\"headerlink\" title=\"子查詢為參數時，使用連結代替 IN\"></a>子查詢為參數時，使用連結代替 IN</h4><p>要改善 IN 的效能，除了使用 EXISTS 改寫，也可以利用連結方式去實現。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> Ａ.id,A.name <span class=\"keyword\">FROM</span> Class_A A <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Class_B B <span class=\"keyword\">ON</span> A.id = B.id;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"避開排序\"><a href=\"#避開排序\" class=\"headerlink\" title=\"避開排序\"></a>避開排序</h2><p>SQL 與程式語言不同，使用者無法直接命令 DBMS 指定排序運算，不過這不代表 DBMS 不執行排序，更精準的說是 DBMS 非常頻繁的偷偷執行排序，也導致使用者不用去理會哪中運算正在執行排序。</p>\n<p>會執行排序如下 :</p>\n<pre><code>1.GROUP BY\n2.ORDER BY\n3.彙總函數(SUM、COUNT、AVG、MAX、MIN)\n4.DISTINCT\n5.UNION、INTERSECT、EXCEPT\n6.視窗函數(RANK ROW_NUMBER)</code></pre>\n<h4 id=\"善用集合運算的-ALL-選項\"><a href=\"#善用集合運算的-ALL-選項\" class=\"headerlink\" title=\"善用集合運算的 ALL 選項\"></a>善用集合運算的 ALL 選項</h4><p>SQL具有UNION、INTERSECT、EXCEPT 三種集合運算子，如果直接使用一定會為了排除重複資料而執行排序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Class_A</span><br><span class=\"line\"> <span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Class_B;</span><br></pre></td></tr></table></figure>\n\n<p>結果</p>\n<table>\n<thead>\n<tr>\n<th>id(識別子)</th>\n<th>name(姓名)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>郁</td>\n</tr>\n<tr>\n<td>2</td>\n<td>瑋</td>\n</tr>\n<tr>\n<td>3</td>\n<td>銘</td>\n</tr>\n<tr>\n<td>4</td>\n<td>靚</td>\n</tr>\n</tbody></table>\n<p>如果不用在乎重複資料或事先知道不會有重複資料，可以利用 UNION ALL 代替，避免執行排序。</p>\n<h4 id=\"以-EXISTS-代替-DISTINCT\"><a href=\"#以-EXISTS-代替-DISTINCT\" class=\"headerlink\" title=\"以 EXISTS 代替 DISTINCT\"></a>以 EXISTS 代替 DISTINCT</h4><p>DISTINCT 也會為了排除重複資料而執行排序。若是為了統整兩張表連結結果而使用 DISTINCT 的情況，也可以使用 EXISTS 代替，也能避免執行排序。</p>\n<p>Items</p>\n<table>\n<thead>\n<tr>\n<th>item_no</th>\n<th>item</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10</td>\n<td>SD 記憶卡</td>\n</tr>\n<tr>\n<td>20</td>\n<td>CD-R</td>\n</tr>\n<tr>\n<td>30</td>\n<td>USB 隨身碟</td>\n</tr>\n<tr>\n<td>40</td>\n<td>DVD</td>\n</tr>\n</tbody></table>\n<p>SalesHistory</p>\n<table>\n<thead>\n<tr>\n<th>sale_date</th>\n<th>item_no</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2020-10-01</td>\n<td>10</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2020-10-01</td>\n<td>20</td>\n<td>10</td>\n</tr>\n<tr>\n<td>2020-10-01</td>\n<td>30</td>\n<td>3</td>\n</tr>\n<tr>\n<td>2020-10-03</td>\n<td>10</td>\n<td>32</td>\n</tr>\n<tr>\n<td>2020-10-03</td>\n<td>30</td>\n<td>12</td>\n</tr>\n<tr>\n<td>2020-10-04</td>\n<td>20</td>\n<td>22</td>\n</tr>\n<tr>\n<td>2020-10-04</td>\n<td>30</td>\n<td>7</td>\n</tr>\n</tbody></table>\n<p>根據上方商品主資料表選出業績表的商品，簡單說就是找出有業績的商品，此時書中說使用IN雖然不錯。但前面提到用連結會更好。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> I.item_no <span class=\"keyword\">FROM</span> Items I <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> SalesHistory SH <span class=\"keyword\">ON</span> I.item_no = SH.item_no;</span><br></pre></td></tr></table></figure>\n\n<p>結果</p>\n<table>\n<thead>\n<tr>\n<th>item_no</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10</td>\n</tr>\n<tr>\n<td>10</td>\n</tr>\n<tr>\n<td>20</td>\n</tr>\n<tr>\n<td>20</td>\n</tr>\n<tr>\n<td>30</td>\n</tr>\n<tr>\n<td>30</td>\n</tr>\n<tr>\n<td>30</td>\n</tr>\n</tbody></table>\n<p>由於是一對多連結，就會出現重複資料，若要將重複資料排除勢必使用DISTINCT那這樣就會執行到排序，所以書中說到最佳解答是使用EXISTS，如此一來就不會執行排序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> item_no <span class=\"keyword\">FROM</span> Items I <span class=\"keyword\">WHERE</span> <span class=\"keyword\">EXISTS</span>(</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SalesHistory SH <span class=\"keyword\">WHERE</span> I.item_no = SH.item_no</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"於極值函數-MAX-MIN-使用索引值\"><a href=\"#於極值函數-MAX-MIN-使用索引值\" class=\"headerlink\" title=\"於極值函數(MAX/MIN)使用索引值\"></a>於極值函數(MAX/MIN)使用索引值</h2><p>SQL內建MAX跟MIN函數，使用時都會進行排序，但如果參數欄位已有索引值，就只需要掃描到該索引值，不需要搜尋整張表。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">這段會需要搜尋整張表格</span><br><span class=\"line\"> <span class=\"keyword\">SELECT</span> <span class=\"keyword\">MAX</span>(item) <span class=\"keyword\">FROM</span> Items</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">這段可以使用到索引值</span><br><span class=\"line\"> <span class=\"keyword\">SELECT</span> <span class=\"keyword\">MAX</span>(item_no) <span class=\"keyword\">FROM</span> Items</span><br></pre></td></tr></table></figure>\n\n<p>由於item_no主鍵的索引值，所以效果更好，即時是複合索引值，只要有首欄位就能使用。雖然這種做法無法真的不排序，但至少可讓前半段搜尋變快，也能提高效率。</p>\n<h2 id=\"寫在WHERE的條件不寫在HAVING上\"><a href=\"#寫在WHERE的條件不寫在HAVING上\" class=\"headerlink\" title=\"寫在WHERE的條件不寫在HAVING上\"></a>寫在WHERE的條件不寫在HAVING上</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> sale_date, <span class=\"keyword\">SUM</span>(quantity)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> SalesHistory </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sale_date <span class=\"keyword\">HAVING</span> sale_date = <span class=\"string\">&#x27;2007-10-01&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> sale_date, <span class=\"keyword\">SUM</span>(quantity)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> SalesHistory <span class=\"keyword\">WHERE</span> sale_date = <span class=\"string\">&#x27;2007-10-01&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sale_date;</span><br></pre></td></tr></table></figure>\n\n<p>結果</p>\n<table>\n<thead>\n<tr>\n<th>sale_date</th>\n<th>sum(quantity)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2007-10-01</td>\n<td>17</td>\n</tr>\n</tbody></table>\n<p>從效能來看一定是後者，原因是第一個使用GROUP BY之後彙整進行排序與運算，所以減少列數，才能減輕排序時負擔。第二個就是WHERE條件可使用索引值。某種意義上，sale_date應該是基數非常高的欄位，所以只要有索引值，應該就能讓列數有效率減少。</p>\n<h4 id=\"GROUP-BY-以及-ORDER-BY使用索引值\"><a href=\"#GROUP-BY-以及-ORDER-BY使用索引值\" class=\"headerlink\" title=\"GROUP BY 以及 ORDER BY使用索引值\"></a>GROUP BY 以及 ORDER BY使用索引值</h4><p>這兩種方式雖然會執行排序，但只要在欄位上加上索引值，就能讓搜尋速度變快，尤其是UNIQUE索引值欄位，有些系統的規格更是能跳過排序。</p>\n<h2 id=\"索引值真的派得上用場嗎\"><a href=\"#索引值真的派得上用場嗎\" class=\"headerlink\" title=\"索引值真的派得上用場嗎?\"></a>索引值真的派得上用場嗎?</h2><p>一般來說資料表有一定規模後，通常就會有索引值。把索引值想像成C語言的指標陣列，意思就是比起搜尋規模較大的物件，搜尋較小的指標會更有效率。</p>\n<pre><code>1.不是索引越多越好，索引可以加快查詢速度，但注意它是以空間換取時間。\n\n2.懂的使用Explain來分析你的SQL索引性能解析，https://segmentfault.com/a/1190000008131735。\n\n3.索引不是建了就會使用。SELECT * FROM user WHERE sex = 0 ( 0 代表女生 )，答案是不一定，如果大部份的值都是女生，那 mysql 會用全掃，如果大部份值為男生，那 mysql 會用索引。\n\n4.連合索引的欄位順序，通常是由最左邊的欄位的才能使用。\n\n5.儘可能使用索引的排序。\n\n6.有時太多索引，反而會讓優化器混亂。</code></pre>\n<h4 id=\"加工索引值欄位\"><a href=\"#加工索引值欄位\" class=\"headerlink\" title=\"加工索引值欄位\"></a>加工索引值欄位</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// NO</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 * <span class=\"number\">1.1</span> &gt; <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">// OK</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 &gt; <span class=\"number\">100</span> / <span class=\"number\">1.1</span></span><br></pre></td></tr></table></figure>\n\n<p>若於搜尋條件右側使用公式，就會用到索引值。因此可以改成下列方式。同樣的在左側使用函數就無法使用到索引值。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> <span class=\"keyword\">SUBSTR</span>(col_1, <span class=\"number\">1</span>, <span class=\"number\">1</span>) = <span class=\"string\">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果非要左邊進行運算，書中說到可以用函數索引，但這種方式很麻煩也不太建議。</p>\n<pre><code> 使用索引值時候，欄位最好是乾淨的。</code></pre>\n<h4 id=\"索引值欄位有NULL\"><a href=\"#索引值欄位有NULL\" class=\"headerlink\" title=\"索引值欄位有NULL\"></a>索引值欄位有NULL</h4><p>索引值有NULL是很難處理的，而且不同規格有不同處理的方式，這也是因為受到使用者使用IS NULL或是IS NOT NULL，<br>就無法使用索引值，或是NULL偏多的欄位無法使用索引的限制導致\b。此外該如何與IS NOT NULL同等條件使用索引值，可以使用下列方式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IS NOT NULL 替代方案</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 &gt; <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用否定型的情況\"><a href=\"#使用否定型的情況\" class=\"headerlink\" title=\"使用否定型的情況\"></a>使用否定型的情況</h4><p>列出否定型不會使用索引值</p>\n<ul>\n<li>&lt;&gt;</li>\n<li>!=</li>\n<li>NOT IN</li>\n</ul>\n<p>因此下列程式也無法取使用索引值。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 &lt;&gt; <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用OR的情況\"><a href=\"#使用OR的情況\" class=\"headerlink\" title=\"使用OR的情況\"></a>使用OR的情況</h4><p>假設col_1與col_2各有索引值情況，或者col_1,col_2有複合索引，使OR撰寫連結條件，就無法使用索引值，而且就算可以使用，搜尋效率也會比AND差。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 &gt; <span class=\"number\">1</span> <span class=\"keyword\">OR</span> col_2 = <span class=\"string\">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"再複合索引下，欄位順序是錯誤的\"><a href=\"#再複合索引下，欄位順序是錯誤的\" class=\"headerlink\" title=\"再複合索引下，欄位順序是錯誤的\"></a>再複合索引下，欄位順序是錯誤的</h4><p>假設以(col_1,col_2,col_3)這個順序下建立索引值，建立索引值欄位順序就相對重要。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">O <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 ＝ <span class=\"number\">10</span> <span class=\"keyword\">AND</span> col_2 = <span class=\"number\">100</span> <span class=\"keyword\">AND</span> col_3 = <span class=\"number\">500</span>;</span><br><span class=\"line\">O <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 ＝ <span class=\"number\">10</span> <span class=\"keyword\">AND</span> col_2 = <span class=\"number\">100</span>;</span><br><span class=\"line\">X <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 ＝ <span class=\"number\">10</span> <span class=\"keyword\">AND</span> col_3 = <span class=\"number\">500</span>;</span><br><span class=\"line\">X <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_2 ＝ <span class=\"number\">100</span> <span class=\"keyword\">AND</span> col_3 = <span class=\"number\">500</span>;</span><br></pre></td></tr></table></figure>\n\n<p>第一個欄位一定寫在開頭，順序不能錯亂。某些DB雖然可能順序錯誤情況也可以使用索引值，但是效能還是比順序正確時來得低。</p>\n<h4 id=\"使用後方一致或中間一致的LIKE\"><a href=\"#使用後方一致或中間一致的LIKE\" class=\"headerlink\" title=\"使用後方一致或中間一致的LIKE\"></a>使用後方一致或中間一致的LIKE</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%10&#x27;</span> ;</span><br><span class=\"line\">X <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%10%&#x27;</span> ;</span><br><span class=\"line\">O <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;10%&#x27;</span> ;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"會進行預設型態轉換\"><a href=\"#會進行預設型態轉換\" class=\"headerlink\" title=\"會進行預設型態轉換\"></a>會進行預設型態轉換</h4><p>下列是對字串類型的col_1設定條件的情況。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 = <span class=\"number\">10</span> ;</span><br><span class=\"line\">O <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 = <span class=\"string\">&#x27;10&#x27;</span> ;</span><br><span class=\"line\">O <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> SomeTable <span class=\"keyword\">WHERE</span> col_1 = <span class=\"keyword\">CAST</span>(<span class=\"number\">10</span>,<span class=\"keyword\">AS</span> <span class=\"built_in\">CHAR</span>(<span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"減少中介資料表\"><a href=\"#減少中介資料表\" class=\"headerlink\" title=\"減少中介資料表\"></a>減少中介資料表</h2><p>SQL會將子查詢結果為新的資料表，也能在程式碼裡，像是操作原始資料表一般操作。這種高正交性讓SQL程式碼更加靈活，但若是大量使用中介資料也會造成性能下滑，所以盡可能減少中介資料。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span>(</span><br><span class=\"line\">     <span class=\"keyword\">SELECT</span> sale_date, <span class=\"keyword\">MAX</span>(quantity) <span class=\"keyword\">AS</span> max_qty <span class=\"keyword\">FROM</span> SalesHistory <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sale_date</span><br><span class=\"line\">) TMP  &lt;-多餘的中介資料</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> max_qty &gt;= <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<p>不過，要將彙整的結果設定條件，是不需要建立多餘中介資料，只需要使用下列HAVING陳述句。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> sale_date, <span class=\"keyword\">MAX</span>(quantity) <span class=\"keyword\">AS</span> max_qty <span class=\"keyword\">FROM</span> SalesHistory <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sale_date <span class=\"keyword\">HAVING</span> <span class=\"keyword\">MAX</span>(quantity) &gt;= <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>HAVING會一邊執行，一邊進行彙整，所以會比建立中介資料表之後才執行WHERE更有效率，且可讀性比較好。</p>\n<h2 id=\"利用IN使用多個KEY時，將KEY整理在同一個位置\"><a href=\"#利用IN使用多個KEY時，將KEY整理在同一個位置\" class=\"headerlink\" title=\"利用IN使用多個KEY時，將KEY整理在同一個位置\"></a>利用IN使用多個KEY時，將KEY整理在同一個位置</h2><p>自從SQL-92之後，就內建許多列間比較的功能，所以=、&lt;、&gt;這類比較或IN的參數不僅可以是純量，還能是LIST。讓我們想想下列這種使用多個Key組成IN內容情況。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">id</span>, state, city <span class=\"keyword\">FROM</span> Address1 A1 </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> </span><br><span class=\"line\"><span class=\"keyword\">status</span> <span class=\"keyword\">IN</span>(</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> <span class=\"keyword\">status</span> <span class=\"keyword\">FROM</span> Address2 A2 <span class=\"keyword\">WHERE</span> A1.id = A2.id      </span><br><span class=\"line\">) <span class=\"keyword\">AND</span> city <span class=\"keyword\">IN</span> (</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> city <span class=\"keyword\">FROM</span> Address2 A2 <span class=\"keyword\">WHERE</span> A1.id = A2.id      </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Address1 A1 <span class=\"keyword\">WHERE</span> <span class=\"keyword\">id</span> || <span class=\"keyword\">status</span> || city <span class=\"keyword\">IN</span>(</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> <span class=\"keyword\">id</span> || state || city <span class=\"keyword\">FROM</span> Address1 A2);</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>如此一來既可將子查詢寫成非關聯式類型，還能將搜尋減少為一次，如果是支援列間比較DB，還能如下在IN的參數設定欄位組合。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Address1 A1 <span class=\"keyword\">WHERE</span> (<span class=\"keyword\">id</span>, <span class=\"keyword\">status</span>, city) <span class=\"keyword\">IN</span>(</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> <span class=\"keyword\">id</span> , state , city <span class=\"keyword\">FROM</span> Address1 A2);</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>相較於合併字串，這個方法有兩個優點。其一是不用擔心連結的類型轉換，另一個需要加工欄位，所以可使用索引值。</p>\n<h2 id=\"先連結在彙整\"><a href=\"#先連結在彙整\" class=\"headerlink\" title=\"先連結在彙整\"></a>先連結在彙整</h2><p>當需要連結使用，盡可能先連結在彙整，才能省去建立中介資料的步驟。之所以能夠省略，全在於集合運算的連結屬於乘法，若具一對一或是一對多的關聯性<br>，列數不會在連結之際增加。</p>\n<h2 id=\"計畫性地使用視圖\"><a href=\"#計畫性地使用視圖\" class=\"headerlink\" title=\"計畫性地使用視圖\"></a>計畫性地使用視圖</h2><p>視圖是非常方便的工具，但如果隨便訂了複雜的視圖將使效能下降，尤其定義是圖的查詢含有下列運算時，SQL的效率將變得更差，執行速度也會出乎意料的下滑。</p>\n<h4 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h4><pre><code>1.在IN使用子查詢，可以利用EXISTS或改寫連結。\n2.使用索引值，基本上左邊是空白的。\n3.SQＬ雖然不需要明定排序部分，但有許多運算會偷偷執行排序，需多加留意。\n4.盡可能減少不需要的中介資料。\n5.趁早撰寫能減少紀錄筆數的條件。</code></pre>\n<p>參考資料: </p>\n<p>1.SQL 達人的工作現場攻略筆</p>\n<p>2.<a href=\"https://ithelp.ithome.com.tw/articles/10221971\">https://ithelp.ithome.com.tw/articles/10221971</a></p>\n"},{"title":"SQL 達人的工作現場攻略筆記 - CH-18 GROUP BY 與 PARTITION BY","date":"2021-01-17T13:00:00.000Z","type":"tags","_content":"\n#### 大家了解兩者的差異嗎?\n\n- group by：對檢索結果的保留行進行單純分組，返回聚合之後的組的數據統計值的記錄。劃分為多組，每組返回一行。\n\n- partition by：返回分組裡的每一條數據，在應用關聯的視窗函數前確定行集的分區和排序，然後，視窗函數將計算每一行的值。\n\nSQL篩選各種資料時，最基本操作就是某種準備替資料分組。其實除了使用SQL之外，日常生活中整理資料、查詢資料時，替資料建群組。\n\n而在SQL中具有建立群組功能就是GROUP BY跟PARTITION BY。這兩種方式都能利用資料表指定的KEY來分割資料，而兩者不同地方在於GROUP BY會再分割後，將資料彙整為1列，而PARTITION BY是將每一欄位取出整理。\n\n透過下列團隊成員資料表說明兩者差異。\n\nTeams\n\n| member | team | age |\n| ------ | ---- | --- |\n| 郁文   | A    | 28  |\n| 瑋乃   | A    | 19  |\n| 銘仁   | A    | 23  |\n| 靚儀   | B    | 40  |\n| 勝朋   | B    | 29  |\n| 美美   | C    | 30  |\n| 建國   | D    | 28  |\n| 崇恩   | D    | 28  |\n| 連雅   | D    | 24  |\n| 光城   | D    | 22  |\n\n若以GROUP BY與PARTITION BY處理這張資料表，可寫出取得團隊資訊的查詢。不管使用哪個陳述句，Teams資料表都會先分割部分集合，再以SUM函數彙整或RANK排出順位。\n\n```sql\nSELECT member,team,age,\nRANK() OVER(PARTITION BY team ORDER BY age DESC) rn,\nDENSE_RANK()  OVER(PARTITION BY team ORDER BY age DESC) dense_rn,\nROW_NUMBER()  OVER(PARTITION BY team ORDER BY age DESC) row_num\nFROM Teams\nORDER BY team, rn\n```\n\n結果\n\n| member | team | age | rn  | dense_rn | row_num |\n| ------ | ---- | --- | --- | -------- | ------- |\n| 郁文   | A    | 28  | 1   | 1        | 1       |\n| 銘仁   | A    | 23  | 2   | 2        | 2       |\n| 瑋乃   | A    | 19  | 3   | 3        | 3       |\n| 靚儀   | B    | 40  | 1   | 1        | 1       |\n| 勝朋   | B    | 29  | 2   | 2        | 2       |\n| 美美   | C    | 30  | 1   | 1        | 1       |\n| 建國   | D    | 28  | 1   | 1        | 1       |\n| 崇恩   | D    | 28  | 1   | 1        | 2       |\n| 連雅   | D    | 24  | 3   | 2        | 3       |\n| 光城   | D    | 22  | 4   | 3        | 4       |\n\n根據書中 286 頁圖片，使用圖形代表集合，是為了呈現分割，經過仔細觀察後發現\n\n    每一個都不是空集合\n    部分集合總和等於分割前的集合\n    隨機從中挑選兩個集合出來，不會有共通得部分。\n\n由於部分集合本來就是從資料表分割而來，所以不會有空集合，且部分集合的總和當然會是分割之的母體集合，所以不會有成員因為分割而失蹤。此外也不會有同時屬於兩個部分集合的成員。每一位成員必然隸屬一個集合。也就是說 GROUP BY與PARTITION BY 可將各成員分割至團隊得函數。\n\n#### 結論\n\nSQL與RDB採用許多集合論以及群的成果，或許內容有點抽象，但也因為抽象內容，所以才廣泛應用。\n\n\n參考資料: \n\n1.SQL 達人的工作現場攻略筆","source":"_posts/sql/202101172100.md","raw":"---\ntitle: SQL 達人的工作現場攻略筆記 - CH-18 GROUP BY 與 PARTITION BY\ndate: 2021-01-17 21:00:00\ntype: \"tags\"\ncategories: 資料庫\ntags: 資料庫\n---\n\n#### 大家了解兩者的差異嗎?\n\n- group by：對檢索結果的保留行進行單純分組，返回聚合之後的組的數據統計值的記錄。劃分為多組，每組返回一行。\n\n- partition by：返回分組裡的每一條數據，在應用關聯的視窗函數前確定行集的分區和排序，然後，視窗函數將計算每一行的值。\n\nSQL篩選各種資料時，最基本操作就是某種準備替資料分組。其實除了使用SQL之外，日常生活中整理資料、查詢資料時，替資料建群組。\n\n而在SQL中具有建立群組功能就是GROUP BY跟PARTITION BY。這兩種方式都能利用資料表指定的KEY來分割資料，而兩者不同地方在於GROUP BY會再分割後，將資料彙整為1列，而PARTITION BY是將每一欄位取出整理。\n\n透過下列團隊成員資料表說明兩者差異。\n\nTeams\n\n| member | team | age |\n| ------ | ---- | --- |\n| 郁文   | A    | 28  |\n| 瑋乃   | A    | 19  |\n| 銘仁   | A    | 23  |\n| 靚儀   | B    | 40  |\n| 勝朋   | B    | 29  |\n| 美美   | C    | 30  |\n| 建國   | D    | 28  |\n| 崇恩   | D    | 28  |\n| 連雅   | D    | 24  |\n| 光城   | D    | 22  |\n\n若以GROUP BY與PARTITION BY處理這張資料表，可寫出取得團隊資訊的查詢。不管使用哪個陳述句，Teams資料表都會先分割部分集合，再以SUM函數彙整或RANK排出順位。\n\n```sql\nSELECT member,team,age,\nRANK() OVER(PARTITION BY team ORDER BY age DESC) rn,\nDENSE_RANK()  OVER(PARTITION BY team ORDER BY age DESC) dense_rn,\nROW_NUMBER()  OVER(PARTITION BY team ORDER BY age DESC) row_num\nFROM Teams\nORDER BY team, rn\n```\n\n結果\n\n| member | team | age | rn  | dense_rn | row_num |\n| ------ | ---- | --- | --- | -------- | ------- |\n| 郁文   | A    | 28  | 1   | 1        | 1       |\n| 銘仁   | A    | 23  | 2   | 2        | 2       |\n| 瑋乃   | A    | 19  | 3   | 3        | 3       |\n| 靚儀   | B    | 40  | 1   | 1        | 1       |\n| 勝朋   | B    | 29  | 2   | 2        | 2       |\n| 美美   | C    | 30  | 1   | 1        | 1       |\n| 建國   | D    | 28  | 1   | 1        | 1       |\n| 崇恩   | D    | 28  | 1   | 1        | 2       |\n| 連雅   | D    | 24  | 3   | 2        | 3       |\n| 光城   | D    | 22  | 4   | 3        | 4       |\n\n根據書中 286 頁圖片，使用圖形代表集合，是為了呈現分割，經過仔細觀察後發現\n\n    每一個都不是空集合\n    部分集合總和等於分割前的集合\n    隨機從中挑選兩個集合出來，不會有共通得部分。\n\n由於部分集合本來就是從資料表分割而來，所以不會有空集合，且部分集合的總和當然會是分割之的母體集合，所以不會有成員因為分割而失蹤。此外也不會有同時屬於兩個部分集合的成員。每一位成員必然隸屬一個集合。也就是說 GROUP BY與PARTITION BY 可將各成員分割至團隊得函數。\n\n#### 結論\n\nSQL與RDB採用許多集合論以及群的成果，或許內容有點抽象，但也因為抽象內容，所以才廣泛應用。\n\n\n參考資料: \n\n1.SQL 達人的工作現場攻略筆","slug":"sql/202101172100","published":1,"updated":"2022-03-16T13:14:45.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0tlcc690008fx7rhjmc4j7f","content":"<h4 id=\"大家了解兩者的差異嗎\"><a href=\"#大家了解兩者的差異嗎\" class=\"headerlink\" title=\"大家了解兩者的差異嗎?\"></a>大家了解兩者的差異嗎?</h4><ul>\n<li><p>group by：對檢索結果的保留行進行單純分組，返回聚合之後的組的數據統計值的記錄。劃分為多組，每組返回一行。</p>\n</li>\n<li><p>partition by：返回分組裡的每一條數據，在應用關聯的視窗函數前確定行集的分區和排序，然後，視窗函數將計算每一行的值。</p>\n</li>\n</ul>\n<p>SQL篩選各種資料時，最基本操作就是某種準備替資料分組。其實除了使用SQL之外，日常生活中整理資料、查詢資料時，替資料建群組。</p>\n<p>而在SQL中具有建立群組功能就是GROUP BY跟PARTITION BY。這兩種方式都能利用資料表指定的KEY來分割資料，而兩者不同地方在於GROUP BY會再分割後，將資料彙整為1列，而PARTITION BY是將每一欄位取出整理。</p>\n<p>透過下列團隊成員資料表說明兩者差異。</p>\n<p>Teams</p>\n<table>\n<thead>\n<tr>\n<th>member</th>\n<th>team</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>郁文</td>\n<td>A</td>\n<td>28</td>\n</tr>\n<tr>\n<td>瑋乃</td>\n<td>A</td>\n<td>19</td>\n</tr>\n<tr>\n<td>銘仁</td>\n<td>A</td>\n<td>23</td>\n</tr>\n<tr>\n<td>靚儀</td>\n<td>B</td>\n<td>40</td>\n</tr>\n<tr>\n<td>勝朋</td>\n<td>B</td>\n<td>29</td>\n</tr>\n<tr>\n<td>美美</td>\n<td>C</td>\n<td>30</td>\n</tr>\n<tr>\n<td>建國</td>\n<td>D</td>\n<td>28</td>\n</tr>\n<tr>\n<td>崇恩</td>\n<td>D</td>\n<td>28</td>\n</tr>\n<tr>\n<td>連雅</td>\n<td>D</td>\n<td>24</td>\n</tr>\n<tr>\n<td>光城</td>\n<td>D</td>\n<td>22</td>\n</tr>\n</tbody></table>\n<p>若以GROUP BY與PARTITION BY處理這張資料表，可寫出取得團隊資訊的查詢。不管使用哪個陳述句，Teams資料表都會先分割部分集合，再以SUM函數彙整或RANK排出順位。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">member</span>,team,age,</span><br><span class=\"line\"><span class=\"keyword\">RANK</span>() <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> team <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> age <span class=\"keyword\">DESC</span>) rn,</span><br><span class=\"line\"><span class=\"keyword\">DENSE_RANK</span>()  <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> team <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> age <span class=\"keyword\">DESC</span>) dense_rn,</span><br><span class=\"line\">ROW_NUMBER()  <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> team <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> age <span class=\"keyword\">DESC</span>) row_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Teams</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> team, rn</span><br></pre></td></tr></table></figure>\n\n<p>結果</p>\n<table>\n<thead>\n<tr>\n<th>member</th>\n<th>team</th>\n<th>age</th>\n<th>rn</th>\n<th>dense_rn</th>\n<th>row_num</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>郁文</td>\n<td>A</td>\n<td>28</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>銘仁</td>\n<td>A</td>\n<td>23</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>瑋乃</td>\n<td>A</td>\n<td>19</td>\n<td>3</td>\n<td>3</td>\n<td>3</td>\n</tr>\n<tr>\n<td>靚儀</td>\n<td>B</td>\n<td>40</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>勝朋</td>\n<td>B</td>\n<td>29</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>美美</td>\n<td>C</td>\n<td>30</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>建國</td>\n<td>D</td>\n<td>28</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>崇恩</td>\n<td>D</td>\n<td>28</td>\n<td>1</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>連雅</td>\n<td>D</td>\n<td>24</td>\n<td>3</td>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr>\n<td>光城</td>\n<td>D</td>\n<td>22</td>\n<td>4</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<p>根據書中 286 頁圖片，使用圖形代表集合，是為了呈現分割，經過仔細觀察後發現</p>\n<pre><code>每一個都不是空集合\n部分集合總和等於分割前的集合\n隨機從中挑選兩個集合出來，不會有共通得部分。</code></pre>\n<p>由於部分集合本來就是從資料表分割而來，所以不會有空集合，且部分集合的總和當然會是分割之的母體集合，所以不會有成員因為分割而失蹤。此外也不會有同時屬於兩個部分集合的成員。每一位成員必然隸屬一個集合。也就是說 GROUP BY與PARTITION BY 可將各成員分割至團隊得函數。</p>\n<h4 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h4><p>SQL與RDB採用許多集合論以及群的成果，或許內容有點抽象，但也因為抽象內容，所以才廣泛應用。</p>\n<p>參考資料: </p>\n<p>1.SQL 達人的工作現場攻略筆</p>\n","site":{"data":{"styles":""}},"excerpt":"大家了解兩者的差異嗎?\n * group by：對檢索結果的保留行進行單純分組，返回聚合之後的組的數據統計值的記錄。劃分為多組，每組返回一行。\n   \n   \n * partition by：返回分組裡的每一條數據，在應用關聯的視窗函數前確定行集的分區和排序，然後，視窗函數將計算每一行的值。\n   \n   \n\nSQL篩選各種資料時，最基本操作就是某種準備替資料分組。其實除了使用SQL之外，日常生活中整理資料、查詢資料時，替資料建群組。\n\n而在SQL中具有建立群組功能就是GROUP BY跟PARTITION BY。這兩種方式都能利用資料表指定的KEY來分割資料，而兩者不同地方在於GROUP BY","more":"<h4 id=\"大家了解兩者的差異嗎\"><a href=\"#大家了解兩者的差異嗎\" class=\"headerlink\" title=\"大家了解兩者的差異嗎?\"></a>大家了解兩者的差異嗎?</h4><ul>\n<li><p>group by：對檢索結果的保留行進行單純分組，返回聚合之後的組的數據統計值的記錄。劃分為多組，每組返回一行。</p>\n</li>\n<li><p>partition by：返回分組裡的每一條數據，在應用關聯的視窗函數前確定行集的分區和排序，然後，視窗函數將計算每一行的值。</p>\n</li>\n</ul>\n<p>SQL篩選各種資料時，最基本操作就是某種準備替資料分組。其實除了使用SQL之外，日常生活中整理資料、查詢資料時，替資料建群組。</p>\n<p>而在SQL中具有建立群組功能就是GROUP BY跟PARTITION BY。這兩種方式都能利用資料表指定的KEY來分割資料，而兩者不同地方在於GROUP BY會再分割後，將資料彙整為1列，而PARTITION BY是將每一欄位取出整理。</p>\n<p>透過下列團隊成員資料表說明兩者差異。</p>\n<p>Teams</p>\n<table>\n<thead>\n<tr>\n<th>member</th>\n<th>team</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>郁文</td>\n<td>A</td>\n<td>28</td>\n</tr>\n<tr>\n<td>瑋乃</td>\n<td>A</td>\n<td>19</td>\n</tr>\n<tr>\n<td>銘仁</td>\n<td>A</td>\n<td>23</td>\n</tr>\n<tr>\n<td>靚儀</td>\n<td>B</td>\n<td>40</td>\n</tr>\n<tr>\n<td>勝朋</td>\n<td>B</td>\n<td>29</td>\n</tr>\n<tr>\n<td>美美</td>\n<td>C</td>\n<td>30</td>\n</tr>\n<tr>\n<td>建國</td>\n<td>D</td>\n<td>28</td>\n</tr>\n<tr>\n<td>崇恩</td>\n<td>D</td>\n<td>28</td>\n</tr>\n<tr>\n<td>連雅</td>\n<td>D</td>\n<td>24</td>\n</tr>\n<tr>\n<td>光城</td>\n<td>D</td>\n<td>22</td>\n</tr>\n</tbody></table>\n<p>若以GROUP BY與PARTITION BY處理這張資料表，可寫出取得團隊資訊的查詢。不管使用哪個陳述句，Teams資料表都會先分割部分集合，再以SUM函數彙整或RANK排出順位。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">member</span>,team,age,</span><br><span class=\"line\"><span class=\"keyword\">RANK</span>() <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> team <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> age <span class=\"keyword\">DESC</span>) rn,</span><br><span class=\"line\"><span class=\"keyword\">DENSE_RANK</span>()  <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> team <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> age <span class=\"keyword\">DESC</span>) dense_rn,</span><br><span class=\"line\">ROW_NUMBER()  <span class=\"keyword\">OVER</span>(<span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> team <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> age <span class=\"keyword\">DESC</span>) row_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Teams</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> team, rn</span><br></pre></td></tr></table></figure>\n\n<p>結果</p>\n<table>\n<thead>\n<tr>\n<th>member</th>\n<th>team</th>\n<th>age</th>\n<th>rn</th>\n<th>dense_rn</th>\n<th>row_num</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>郁文</td>\n<td>A</td>\n<td>28</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>銘仁</td>\n<td>A</td>\n<td>23</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>瑋乃</td>\n<td>A</td>\n<td>19</td>\n<td>3</td>\n<td>3</td>\n<td>3</td>\n</tr>\n<tr>\n<td>靚儀</td>\n<td>B</td>\n<td>40</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>勝朋</td>\n<td>B</td>\n<td>29</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>美美</td>\n<td>C</td>\n<td>30</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>建國</td>\n<td>D</td>\n<td>28</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>崇恩</td>\n<td>D</td>\n<td>28</td>\n<td>1</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>連雅</td>\n<td>D</td>\n<td>24</td>\n<td>3</td>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr>\n<td>光城</td>\n<td>D</td>\n<td>22</td>\n<td>4</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<p>根據書中 286 頁圖片，使用圖形代表集合，是為了呈現分割，經過仔細觀察後發現</p>\n<pre><code>每一個都不是空集合\n部分集合總和等於分割前的集合\n隨機從中挑選兩個集合出來，不會有共通得部分。</code></pre>\n<p>由於部分集合本來就是從資料表分割而來，所以不會有空集合，且部分集合的總和當然會是分割之的母體集合，所以不會有成員因為分割而失蹤。此外也不會有同時屬於兩個部分集合的成員。每一位成員必然隸屬一個集合。也就是說 GROUP BY與PARTITION BY 可將各成員分割至團隊得函數。</p>\n<h4 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h4><p>SQL與RDB採用許多集合論以及群的成果，或許內容有點抽象，但也因為抽象內容，所以才廣泛應用。</p>\n<p>參考資料: </p>\n<p>1.SQL 達人的工作現場攻略筆</p>\n"},{"title":"單元測試的藝術 第二版 - 01 單元測試藝術","date":"2021-03-06T08:55:16.000Z","type":"tags","_content":"\n\n## 單元測試基礎\n\n#### 1.1 逐步定義單元測試\n\n在軟體開發領域上，單元測試並非一個概念，從1970年代使用過的測試設計程式時，單元測試就已經出現了，而Kent Beck在Smalltalk中加入單元測試概念，這個概念也帶入到許多程式語言上。\n而單元測試的定義上需要定義的更好一些。\n\n    定義1.0 一個單元測試就是一段程式碼，這段程式碼呼叫另一個程式碼，\n    然後驗證某些假設性問題正確性。如果驗證錯誤，則單元測試就會失敗，\n    一個單元可以是一個方法或函數。\n\n被你的測試程式所測試的對象，稱之為(被測試系統)(System Under Test SUT)。\n\n    定義\n    從呼叫系統一個公開方法，到產生一個測試可見最終結果，在期間系統所發生的行為統稱為一個\n    工作單元。所謂一個可見最終結果指的是，我們只需要透過系統的公共API和行為就可以觀察，\n    而不需要透過系統內部狀態才能得知結果。一個最終結果可以以下其中的形式：\n    * 被呼叫的公開方法回傳一個結果值(一個非回傳void函數)。\n    * 被呼叫方法的前後，系統可見的狀態或行為發生變化，這樣的變化不需要透過查詢私有狀態就能取得與判斷。\n    * 呼叫一個不受測試所控制的第三方系統，這個第三方系統並不回傳任何值。\n\n工作單元這個概念意味著一個單元，它既可以小到只包含一個方法，也可以大到包括某個功能。\n\n    一個單元測試是一段呼叫一個工作單元，並驗證工作單元的一個具體結果。\n    如果對這個結果假設是錯誤的，那單元就是失敗了。\n\n不管是哪個程式語言，在定義單元測試時，最難的事情之一，就是定義何謂優秀的單元測試。\n\n##### 1.1.1 撰寫優秀的單元測試\n\n大部分嘗試對自己程式進行單元測試的人，都會在某個階段就放棄，也會有在產品生命週期後期，依賴系統測試或整合測試來發現問題，或是客製化出一些用來進行測試的系統，然後手動測試。以及寫出的單元測試品質很差，那一點意義也沒有。那乾脆不要寫測試，至少省掉日後維護得成本和時間。透過定義什麼叫做優秀的單元測試，得暸解開發人員在測試上做些什麼。\n\n##### 1.1.2 我們都寫過的單元測試\n\n傳統測試開發人員透過一個圖形介面來觸發測試的某個行為，接著驗證結果，這測試也許有用，且也接近於傳統定義的單元測試，但它和書中所定義優秀的單元測試還有很大的距離。\n\n#### 1.2 優秀的單元測試特質\n\n單元測試應該具備特質:\n\n* 自動化，且可以重複執行。\n* 容易實現。\n* 第二天應該還有存在意義。\n* 任何人可以執行它。\n* 執行速度快。\n* 執行結果一致。\n* 完全掌握被測試的單元。\n* 完全被隔離的(執行時獨立於其他測試)\n* 執行結果失敗，應該要簡單清楚呈現我們的期望，發生問題原因在哪。\n\n#### 1.3 整合測試\n\n任何測試，假設測試執行速度不夠快，結果不穩定，或是被測試單元要用一個到多個真實相依物件，作者認為他就是一種整合測試。例如:一個測試需要用到系統真實的時間、真實的檔案系統或是真實的資料庫，那這個測試就是屬於整合測試。這種測試本身並不是壞事，只是應該被分開，營造出一種綠色安全區域。以及整合測試帶來另個問題就是，一次測試太多東西。\n\n更好的整合測試定義\n\n    整合測試是對一個工作單元進行測試，而這個測試對被測試單元並沒有完全的控制，而是使用該單元一個或多個真實依賴相依物件，例如時間、網路、資料庫等，\n\n總體來說，整合測試實際使用真實相依物件或資源，而單元測試則是把被測試單元與其他相依物件或資源隔離開來，以保證單元測試結果高度穩定。\n\n##### 1.3.1 與自動化單元測試相比，非自動化整合測試的缺點\n\n* 我兩週前寫的單元測試，今天還能正常執行結果嗎?幾個月前寫的呢?幾年前寫的?\n\n  如果回答不能。那你怎麼知道自己是不是已經破壞了以前完成某個功能呢?程式碼會一直變化，你不能對之前所有功能進行測試，當然就可能發生改壞東西狀況。書中說明這是不經意的bug。\n\n  回歸:是以前運作正常但現在無法正常運作的一個或多個工作單元。\n\n* 我兩個月前所寫的單元測試，我團隊中任何一個人是否都能夠執行它並得到結果?\n\n  這個問題是上一個問題進階版，當你對程式碼做任何修改，需要保證自己沒有弄壞別人的程式與功能。許多人開發人員害怕修改以前系統中遺留的程式碼，就是因為擔心改壞，以及修改完系統不是穩定的。優秀單元測試總是可以被任何人所存取修改。\n\n  遺留的程式碼:維基百科中定義為一段作業系統或其他電腦科技不再支援或製造的程式碼，但很多公司把任何比目前版本老舊程式碼都稱之為遺留程式碼。此名稱形容難以維護、難以測試以及難以閱讀。\n\n* 我能在幾分鐘跑完所有單元測試嗎?\n\n  如果你不能很快地執行完所有測試(在幾秒鐘內完成，比起幾分鐘才能完成要好得多)，你就不會經常執行它們。問題是，如果修改程式，你想盡早回饋確保自己沒弄壞什麼功能。當執行測試週期越長，你對系統未經測試的修改越多，出現問題時可能的原因點就越多。\n\n  優秀的單元測試執行速度應該很快。\n\n* 我能一鍵執行所有我寫過的單元測試嗎?\n  \n  如果不能，那意味你可能需要對執行測試機器進行一些設定，才能讓測試能正常執行，或是你的測試並非完全自動化。如果不能將單元測試自動化，你可能每次重複測試的時候，跳過這些沒被自動化的測試程式。\n\n  優秀的測試無需進行額外手動的設定或處理，就能被自動執行。\n\n* 我能在幾分鐘寫出一個基本單元測試嗎？\n\n  單元測試其中一個特色，就是測試出每個問題細節，而不是關注於大問題。當你只關注較大的問題，測試的邏輯覆蓋率就會比較低，程式碼中很多核心邏輯不會被測試到，這樣就可能出現未曾可慮到的bug，一旦你已經發現適合測試你的物件模型的模式後，優秀的單元測試，應該要很容易，很快速被撰寫完。一個小警告:面對一個沒有被單元測試保護的物件模型，即便是有經驗的單元測試人員，也需要花上30分鐘或更長時間撰寫出第一個好的單元測試。\n\n\n#### 1.4 什麼是優秀的單元測試\n\n一個單元測試是一段自動化程式碼，這段程式會呼叫被測試的工作單元，之後對這個單元的單一最終結得某些假設或期望進行驗證。單元測試幾乎都是靠使用單元測試框架進行撰寫。單元測試可靠、易讀、易維護。只要產品程式碼不發生變化，單元測試執行結果是穩定一致。\n\n\n作者說:前一版本只針對控制流程屬於單元的一部分，但作者現在不這麼認為。沒有邏輯判斷程式碼通常屬於工作單元的一部分。\n\n    控制程式碼:通常包含某種邏輯，無論是規模有多小。控制流程程式碼包含下面列舉:if語句、loop或switch或case語句。\n\n\n參考資料: \n\n1.單元測試的藝術 第二版","source":"_posts/unit-test/202103061655.md","raw":"---\ntitle: 單元測試的藝術 第二版 - 01 單元測試藝術\ndate: 2021-03-06 16:55:16\ntype: \"tags\"\ncategories: 單元測試\ntags: 單元測試\n---\n\n\n## 單元測試基礎\n\n#### 1.1 逐步定義單元測試\n\n在軟體開發領域上，單元測試並非一個概念，從1970年代使用過的測試設計程式時，單元測試就已經出現了，而Kent Beck在Smalltalk中加入單元測試概念，這個概念也帶入到許多程式語言上。\n而單元測試的定義上需要定義的更好一些。\n\n    定義1.0 一個單元測試就是一段程式碼，這段程式碼呼叫另一個程式碼，\n    然後驗證某些假設性問題正確性。如果驗證錯誤，則單元測試就會失敗，\n    一個單元可以是一個方法或函數。\n\n被你的測試程式所測試的對象，稱之為(被測試系統)(System Under Test SUT)。\n\n    定義\n    從呼叫系統一個公開方法，到產生一個測試可見最終結果，在期間系統所發生的行為統稱為一個\n    工作單元。所謂一個可見最終結果指的是，我們只需要透過系統的公共API和行為就可以觀察，\n    而不需要透過系統內部狀態才能得知結果。一個最終結果可以以下其中的形式：\n    * 被呼叫的公開方法回傳一個結果值(一個非回傳void函數)。\n    * 被呼叫方法的前後，系統可見的狀態或行為發生變化，這樣的變化不需要透過查詢私有狀態就能取得與判斷。\n    * 呼叫一個不受測試所控制的第三方系統，這個第三方系統並不回傳任何值。\n\n工作單元這個概念意味著一個單元，它既可以小到只包含一個方法，也可以大到包括某個功能。\n\n    一個單元測試是一段呼叫一個工作單元，並驗證工作單元的一個具體結果。\n    如果對這個結果假設是錯誤的，那單元就是失敗了。\n\n不管是哪個程式語言，在定義單元測試時，最難的事情之一，就是定義何謂優秀的單元測試。\n\n##### 1.1.1 撰寫優秀的單元測試\n\n大部分嘗試對自己程式進行單元測試的人，都會在某個階段就放棄，也會有在產品生命週期後期，依賴系統測試或整合測試來發現問題，或是客製化出一些用來進行測試的系統，然後手動測試。以及寫出的單元測試品質很差，那一點意義也沒有。那乾脆不要寫測試，至少省掉日後維護得成本和時間。透過定義什麼叫做優秀的單元測試，得暸解開發人員在測試上做些什麼。\n\n##### 1.1.2 我們都寫過的單元測試\n\n傳統測試開發人員透過一個圖形介面來觸發測試的某個行為，接著驗證結果，這測試也許有用，且也接近於傳統定義的單元測試，但它和書中所定義優秀的單元測試還有很大的距離。\n\n#### 1.2 優秀的單元測試特質\n\n單元測試應該具備特質:\n\n* 自動化，且可以重複執行。\n* 容易實現。\n* 第二天應該還有存在意義。\n* 任何人可以執行它。\n* 執行速度快。\n* 執行結果一致。\n* 完全掌握被測試的單元。\n* 完全被隔離的(執行時獨立於其他測試)\n* 執行結果失敗，應該要簡單清楚呈現我們的期望，發生問題原因在哪。\n\n#### 1.3 整合測試\n\n任何測試，假設測試執行速度不夠快，結果不穩定，或是被測試單元要用一個到多個真實相依物件，作者認為他就是一種整合測試。例如:一個測試需要用到系統真實的時間、真實的檔案系統或是真實的資料庫，那這個測試就是屬於整合測試。這種測試本身並不是壞事，只是應該被分開，營造出一種綠色安全區域。以及整合測試帶來另個問題就是，一次測試太多東西。\n\n更好的整合測試定義\n\n    整合測試是對一個工作單元進行測試，而這個測試對被測試單元並沒有完全的控制，而是使用該單元一個或多個真實依賴相依物件，例如時間、網路、資料庫等，\n\n總體來說，整合測試實際使用真實相依物件或資源，而單元測試則是把被測試單元與其他相依物件或資源隔離開來，以保證單元測試結果高度穩定。\n\n##### 1.3.1 與自動化單元測試相比，非自動化整合測試的缺點\n\n* 我兩週前寫的單元測試，今天還能正常執行結果嗎?幾個月前寫的呢?幾年前寫的?\n\n  如果回答不能。那你怎麼知道自己是不是已經破壞了以前完成某個功能呢?程式碼會一直變化，你不能對之前所有功能進行測試，當然就可能發生改壞東西狀況。書中說明這是不經意的bug。\n\n  回歸:是以前運作正常但現在無法正常運作的一個或多個工作單元。\n\n* 我兩個月前所寫的單元測試，我團隊中任何一個人是否都能夠執行它並得到結果?\n\n  這個問題是上一個問題進階版，當你對程式碼做任何修改，需要保證自己沒有弄壞別人的程式與功能。許多人開發人員害怕修改以前系統中遺留的程式碼，就是因為擔心改壞，以及修改完系統不是穩定的。優秀單元測試總是可以被任何人所存取修改。\n\n  遺留的程式碼:維基百科中定義為一段作業系統或其他電腦科技不再支援或製造的程式碼，但很多公司把任何比目前版本老舊程式碼都稱之為遺留程式碼。此名稱形容難以維護、難以測試以及難以閱讀。\n\n* 我能在幾分鐘跑完所有單元測試嗎?\n\n  如果你不能很快地執行完所有測試(在幾秒鐘內完成，比起幾分鐘才能完成要好得多)，你就不會經常執行它們。問題是，如果修改程式，你想盡早回饋確保自己沒弄壞什麼功能。當執行測試週期越長，你對系統未經測試的修改越多，出現問題時可能的原因點就越多。\n\n  優秀的單元測試執行速度應該很快。\n\n* 我能一鍵執行所有我寫過的單元測試嗎?\n  \n  如果不能，那意味你可能需要對執行測試機器進行一些設定，才能讓測試能正常執行，或是你的測試並非完全自動化。如果不能將單元測試自動化，你可能每次重複測試的時候，跳過這些沒被自動化的測試程式。\n\n  優秀的測試無需進行額外手動的設定或處理，就能被自動執行。\n\n* 我能在幾分鐘寫出一個基本單元測試嗎？\n\n  單元測試其中一個特色，就是測試出每個問題細節，而不是關注於大問題。當你只關注較大的問題，測試的邏輯覆蓋率就會比較低，程式碼中很多核心邏輯不會被測試到，這樣就可能出現未曾可慮到的bug，一旦你已經發現適合測試你的物件模型的模式後，優秀的單元測試，應該要很容易，很快速被撰寫完。一個小警告:面對一個沒有被單元測試保護的物件模型，即便是有經驗的單元測試人員，也需要花上30分鐘或更長時間撰寫出第一個好的單元測試。\n\n\n#### 1.4 什麼是優秀的單元測試\n\n一個單元測試是一段自動化程式碼，這段程式會呼叫被測試的工作單元，之後對這個單元的單一最終結得某些假設或期望進行驗證。單元測試幾乎都是靠使用單元測試框架進行撰寫。單元測試可靠、易讀、易維護。只要產品程式碼不發生變化，單元測試執行結果是穩定一致。\n\n\n作者說:前一版本只針對控制流程屬於單元的一部分，但作者現在不這麼認為。沒有邏輯判斷程式碼通常屬於工作單元的一部分。\n\n    控制程式碼:通常包含某種邏輯，無論是規模有多小。控制流程程式碼包含下面列舉:if語句、loop或switch或case語句。\n\n\n參考資料: \n\n1.單元測試的藝術 第二版","slug":"unit-test/202103061655","published":1,"updated":"2022-03-16T13:16:09.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0tlcc6a0009fx7rfd4r0mba","content":"<h2 id=\"單元測試基礎\"><a href=\"#單元測試基礎\" class=\"headerlink\" title=\"單元測試基礎\"></a>單元測試基礎</h2><h4 id=\"1-1-逐步定義單元測試\"><a href=\"#1-1-逐步定義單元測試\" class=\"headerlink\" title=\"1.1 逐步定義單元測試\"></a>1.1 逐步定義單元測試</h4><p>在軟體開發領域上，單元測試並非一個概念，從1970年代使用過的測試設計程式時，單元測試就已經出現了，而Kent Beck在Smalltalk中加入單元測試概念，這個概念也帶入到許多程式語言上。<br>而單元測試的定義上需要定義的更好一些。</p>\n<pre><code>定義1.0 一個單元測試就是一段程式碼，這段程式碼呼叫另一個程式碼，\n然後驗證某些假設性問題正確性。如果驗證錯誤，則單元測試就會失敗，\n一個單元可以是一個方法或函數。</code></pre>\n<p>被你的測試程式所測試的對象，稱之為(被測試系統)(System Under Test SUT)。</p>\n<pre><code>定義\n從呼叫系統一個公開方法，到產生一個測試可見最終結果，在期間系統所發生的行為統稱為一個\n工作單元。所謂一個可見最終結果指的是，我們只需要透過系統的公共API和行為就可以觀察，\n而不需要透過系統內部狀態才能得知結果。一個最終結果可以以下其中的形式：\n* 被呼叫的公開方法回傳一個結果值(一個非回傳void函數)。\n* 被呼叫方法的前後，系統可見的狀態或行為發生變化，這樣的變化不需要透過查詢私有狀態就能取得與判斷。\n* 呼叫一個不受測試所控制的第三方系統，這個第三方系統並不回傳任何值。</code></pre>\n<p>工作單元這個概念意味著一個單元，它既可以小到只包含一個方法，也可以大到包括某個功能。</p>\n<pre><code>一個單元測試是一段呼叫一個工作單元，並驗證工作單元的一個具體結果。\n如果對這個結果假設是錯誤的，那單元就是失敗了。</code></pre>\n<p>不管是哪個程式語言，在定義單元測試時，最難的事情之一，就是定義何謂優秀的單元測試。</p>\n<h5 id=\"1-1-1-撰寫優秀的單元測試\"><a href=\"#1-1-1-撰寫優秀的單元測試\" class=\"headerlink\" title=\"1.1.1 撰寫優秀的單元測試\"></a>1.1.1 撰寫優秀的單元測試</h5><p>大部分嘗試對自己程式進行單元測試的人，都會在某個階段就放棄，也會有在產品生命週期後期，依賴系統測試或整合測試來發現問題，或是客製化出一些用來進行測試的系統，然後手動測試。以及寫出的單元測試品質很差，那一點意義也沒有。那乾脆不要寫測試，至少省掉日後維護得成本和時間。透過定義什麼叫做優秀的單元測試，得暸解開發人員在測試上做些什麼。</p>\n<h5 id=\"1-1-2-我們都寫過的單元測試\"><a href=\"#1-1-2-我們都寫過的單元測試\" class=\"headerlink\" title=\"1.1.2 我們都寫過的單元測試\"></a>1.1.2 我們都寫過的單元測試</h5><p>傳統測試開發人員透過一個圖形介面來觸發測試的某個行為，接著驗證結果，這測試也許有用，且也接近於傳統定義的單元測試，但它和書中所定義優秀的單元測試還有很大的距離。</p>\n<h4 id=\"1-2-優秀的單元測試特質\"><a href=\"#1-2-優秀的單元測試特質\" class=\"headerlink\" title=\"1.2 優秀的單元測試特質\"></a>1.2 優秀的單元測試特質</h4><p>單元測試應該具備特質:</p>\n<ul>\n<li>自動化，且可以重複執行。</li>\n<li>容易實現。</li>\n<li>第二天應該還有存在意義。</li>\n<li>任何人可以執行它。</li>\n<li>執行速度快。</li>\n<li>執行結果一致。</li>\n<li>完全掌握被測試的單元。</li>\n<li>完全被隔離的(執行時獨立於其他測試)</li>\n<li>執行結果失敗，應該要簡單清楚呈現我們的期望，發生問題原因在哪。</li>\n</ul>\n<h4 id=\"1-3-整合測試\"><a href=\"#1-3-整合測試\" class=\"headerlink\" title=\"1.3 整合測試\"></a>1.3 整合測試</h4><p>任何測試，假設測試執行速度不夠快，結果不穩定，或是被測試單元要用一個到多個真實相依物件，作者認為他就是一種整合測試。例如:一個測試需要用到系統真實的時間、真實的檔案系統或是真實的資料庫，那這個測試就是屬於整合測試。這種測試本身並不是壞事，只是應該被分開，營造出一種綠色安全區域。以及整合測試帶來另個問題就是，一次測試太多東西。</p>\n<p>更好的整合測試定義</p>\n<pre><code>整合測試是對一個工作單元進行測試，而這個測試對被測試單元並沒有完全的控制，而是使用該單元一個或多個真實依賴相依物件，例如時間、網路、資料庫等，</code></pre>\n<p>總體來說，整合測試實際使用真實相依物件或資源，而單元測試則是把被測試單元與其他相依物件或資源隔離開來，以保證單元測試結果高度穩定。</p>\n<h5 id=\"1-3-1-與自動化單元測試相比，非自動化整合測試的缺點\"><a href=\"#1-3-1-與自動化單元測試相比，非自動化整合測試的缺點\" class=\"headerlink\" title=\"1.3.1 與自動化單元測試相比，非自動化整合測試的缺點\"></a>1.3.1 與自動化單元測試相比，非自動化整合測試的缺點</h5><ul>\n<li><p>我兩週前寫的單元測試，今天還能正常執行結果嗎?幾個月前寫的呢?幾年前寫的?</p>\n<p>如果回答不能。那你怎麼知道自己是不是已經破壞了以前完成某個功能呢?程式碼會一直變化，你不能對之前所有功能進行測試，當然就可能發生改壞東西狀況。書中說明這是不經意的bug。</p>\n<p>回歸:是以前運作正常但現在無法正常運作的一個或多個工作單元。</p>\n</li>\n<li><p>我兩個月前所寫的單元測試，我團隊中任何一個人是否都能夠執行它並得到結果?</p>\n<p>這個問題是上一個問題進階版，當你對程式碼做任何修改，需要保證自己沒有弄壞別人的程式與功能。許多人開發人員害怕修改以前系統中遺留的程式碼，就是因為擔心改壞，以及修改完系統不是穩定的。優秀單元測試總是可以被任何人所存取修改。</p>\n<p>遺留的程式碼:維基百科中定義為一段作業系統或其他電腦科技不再支援或製造的程式碼，但很多公司把任何比目前版本老舊程式碼都稱之為遺留程式碼。此名稱形容難以維護、難以測試以及難以閱讀。</p>\n</li>\n<li><p>我能在幾分鐘跑完所有單元測試嗎?</p>\n<p>如果你不能很快地執行完所有測試(在幾秒鐘內完成，比起幾分鐘才能完成要好得多)，你就不會經常執行它們。問題是，如果修改程式，你想盡早回饋確保自己沒弄壞什麼功能。當執行測試週期越長，你對系統未經測試的修改越多，出現問題時可能的原因點就越多。</p>\n<p>優秀的單元測試執行速度應該很快。</p>\n</li>\n<li><p>我能一鍵執行所有我寫過的單元測試嗎?</p>\n<p>如果不能，那意味你可能需要對執行測試機器進行一些設定，才能讓測試能正常執行，或是你的測試並非完全自動化。如果不能將單元測試自動化，你可能每次重複測試的時候，跳過這些沒被自動化的測試程式。</p>\n<p>優秀的測試無需進行額外手動的設定或處理，就能被自動執行。</p>\n</li>\n<li><p>我能在幾分鐘寫出一個基本單元測試嗎？</p>\n<p>單元測試其中一個特色，就是測試出每個問題細節，而不是關注於大問題。當你只關注較大的問題，測試的邏輯覆蓋率就會比較低，程式碼中很多核心邏輯不會被測試到，這樣就可能出現未曾可慮到的bug，一旦你已經發現適合測試你的物件模型的模式後，優秀的單元測試，應該要很容易，很快速被撰寫完。一個小警告:面對一個沒有被單元測試保護的物件模型，即便是有經驗的單元測試人員，也需要花上30分鐘或更長時間撰寫出第一個好的單元測試。</p>\n</li>\n</ul>\n<h4 id=\"1-4-什麼是優秀的單元測試\"><a href=\"#1-4-什麼是優秀的單元測試\" class=\"headerlink\" title=\"1.4 什麼是優秀的單元測試\"></a>1.4 什麼是優秀的單元測試</h4><p>一個單元測試是一段自動化程式碼，這段程式會呼叫被測試的工作單元，之後對這個單元的單一最終結得某些假設或期望進行驗證。單元測試幾乎都是靠使用單元測試框架進行撰寫。單元測試可靠、易讀、易維護。只要產品程式碼不發生變化，單元測試執行結果是穩定一致。</p>\n<p>作者說:前一版本只針對控制流程屬於單元的一部分，但作者現在不這麼認為。沒有邏輯判斷程式碼通常屬於工作單元的一部分。</p>\n<pre><code>控制程式碼:通常包含某種邏輯，無論是規模有多小。控制流程程式碼包含下面列舉:if語句、loop或switch或case語句。</code></pre>\n<p>參考資料: </p>\n<p>1.單元測試的藝術 第二版</p>\n","site":{"data":{"styles":""}},"excerpt":"單元測試基礎\n1.1 逐步定義單元測試\n在軟體開發領域上，單元測試並非一個概念，從1970年代使用過的測試設計程式時，單元測試就已經出現了，而Kent Beck在Smalltalk中加入單元測試概念，這個概念也帶入到許多程式語言上。\n而單元測試的定義上需要定義的更好一些。\n\n定義1.0 一個單元測試就是一段程式碼，這段程式碼呼叫另一個程式碼，\n然後驗證某些假設性問題正確性。如果驗證錯誤，則單元測試就會失敗，\n一個單元可以是一個方法或函數。\n\n被你的測試程式所測試的對象，稱之為(被測試系統)(System Under Test SUT)。\n\n定義\n從呼叫系統一個公開方法，到產生一個測試可見最終結","more":"<h2 id=\"單元測試基礎\"><a href=\"#單元測試基礎\" class=\"headerlink\" title=\"單元測試基礎\"></a>單元測試基礎</h2><h4 id=\"1-1-逐步定義單元測試\"><a href=\"#1-1-逐步定義單元測試\" class=\"headerlink\" title=\"1.1 逐步定義單元測試\"></a>1.1 逐步定義單元測試</h4><p>在軟體開發領域上，單元測試並非一個概念，從1970年代使用過的測試設計程式時，單元測試就已經出現了，而Kent Beck在Smalltalk中加入單元測試概念，這個概念也帶入到許多程式語言上。<br>而單元測試的定義上需要定義的更好一些。</p>\n<pre><code>定義1.0 一個單元測試就是一段程式碼，這段程式碼呼叫另一個程式碼，\n然後驗證某些假設性問題正確性。如果驗證錯誤，則單元測試就會失敗，\n一個單元可以是一個方法或函數。</code></pre>\n<p>被你的測試程式所測試的對象，稱之為(被測試系統)(System Under Test SUT)。</p>\n<pre><code>定義\n從呼叫系統一個公開方法，到產生一個測試可見最終結果，在期間系統所發生的行為統稱為一個\n工作單元。所謂一個可見最終結果指的是，我們只需要透過系統的公共API和行為就可以觀察，\n而不需要透過系統內部狀態才能得知結果。一個最終結果可以以下其中的形式：\n* 被呼叫的公開方法回傳一個結果值(一個非回傳void函數)。\n* 被呼叫方法的前後，系統可見的狀態或行為發生變化，這樣的變化不需要透過查詢私有狀態就能取得與判斷。\n* 呼叫一個不受測試所控制的第三方系統，這個第三方系統並不回傳任何值。</code></pre>\n<p>工作單元這個概念意味著一個單元，它既可以小到只包含一個方法，也可以大到包括某個功能。</p>\n<pre><code>一個單元測試是一段呼叫一個工作單元，並驗證工作單元的一個具體結果。\n如果對這個結果假設是錯誤的，那單元就是失敗了。</code></pre>\n<p>不管是哪個程式語言，在定義單元測試時，最難的事情之一，就是定義何謂優秀的單元測試。</p>\n<h5 id=\"1-1-1-撰寫優秀的單元測試\"><a href=\"#1-1-1-撰寫優秀的單元測試\" class=\"headerlink\" title=\"1.1.1 撰寫優秀的單元測試\"></a>1.1.1 撰寫優秀的單元測試</h5><p>大部分嘗試對自己程式進行單元測試的人，都會在某個階段就放棄，也會有在產品生命週期後期，依賴系統測試或整合測試來發現問題，或是客製化出一些用來進行測試的系統，然後手動測試。以及寫出的單元測試品質很差，那一點意義也沒有。那乾脆不要寫測試，至少省掉日後維護得成本和時間。透過定義什麼叫做優秀的單元測試，得暸解開發人員在測試上做些什麼。</p>\n<h5 id=\"1-1-2-我們都寫過的單元測試\"><a href=\"#1-1-2-我們都寫過的單元測試\" class=\"headerlink\" title=\"1.1.2 我們都寫過的單元測試\"></a>1.1.2 我們都寫過的單元測試</h5><p>傳統測試開發人員透過一個圖形介面來觸發測試的某個行為，接著驗證結果，這測試也許有用，且也接近於傳統定義的單元測試，但它和書中所定義優秀的單元測試還有很大的距離。</p>\n<h4 id=\"1-2-優秀的單元測試特質\"><a href=\"#1-2-優秀的單元測試特質\" class=\"headerlink\" title=\"1.2 優秀的單元測試特質\"></a>1.2 優秀的單元測試特質</h4><p>單元測試應該具備特質:</p>\n<ul>\n<li>自動化，且可以重複執行。</li>\n<li>容易實現。</li>\n<li>第二天應該還有存在意義。</li>\n<li>任何人可以執行它。</li>\n<li>執行速度快。</li>\n<li>執行結果一致。</li>\n<li>完全掌握被測試的單元。</li>\n<li>完全被隔離的(執行時獨立於其他測試)</li>\n<li>執行結果失敗，應該要簡單清楚呈現我們的期望，發生問題原因在哪。</li>\n</ul>\n<h4 id=\"1-3-整合測試\"><a href=\"#1-3-整合測試\" class=\"headerlink\" title=\"1.3 整合測試\"></a>1.3 整合測試</h4><p>任何測試，假設測試執行速度不夠快，結果不穩定，或是被測試單元要用一個到多個真實相依物件，作者認為他就是一種整合測試。例如:一個測試需要用到系統真實的時間、真實的檔案系統或是真實的資料庫，那這個測試就是屬於整合測試。這種測試本身並不是壞事，只是應該被分開，營造出一種綠色安全區域。以及整合測試帶來另個問題就是，一次測試太多東西。</p>\n<p>更好的整合測試定義</p>\n<pre><code>整合測試是對一個工作單元進行測試，而這個測試對被測試單元並沒有完全的控制，而是使用該單元一個或多個真實依賴相依物件，例如時間、網路、資料庫等，</code></pre>\n<p>總體來說，整合測試實際使用真實相依物件或資源，而單元測試則是把被測試單元與其他相依物件或資源隔離開來，以保證單元測試結果高度穩定。</p>\n<h5 id=\"1-3-1-與自動化單元測試相比，非自動化整合測試的缺點\"><a href=\"#1-3-1-與自動化單元測試相比，非自動化整合測試的缺點\" class=\"headerlink\" title=\"1.3.1 與自動化單元測試相比，非自動化整合測試的缺點\"></a>1.3.1 與自動化單元測試相比，非自動化整合測試的缺點</h5><ul>\n<li><p>我兩週前寫的單元測試，今天還能正常執行結果嗎?幾個月前寫的呢?幾年前寫的?</p>\n<p>如果回答不能。那你怎麼知道自己是不是已經破壞了以前完成某個功能呢?程式碼會一直變化，你不能對之前所有功能進行測試，當然就可能發生改壞東西狀況。書中說明這是不經意的bug。</p>\n<p>回歸:是以前運作正常但現在無法正常運作的一個或多個工作單元。</p>\n</li>\n<li><p>我兩個月前所寫的單元測試，我團隊中任何一個人是否都能夠執行它並得到結果?</p>\n<p>這個問題是上一個問題進階版，當你對程式碼做任何修改，需要保證自己沒有弄壞別人的程式與功能。許多人開發人員害怕修改以前系統中遺留的程式碼，就是因為擔心改壞，以及修改完系統不是穩定的。優秀單元測試總是可以被任何人所存取修改。</p>\n<p>遺留的程式碼:維基百科中定義為一段作業系統或其他電腦科技不再支援或製造的程式碼，但很多公司把任何比目前版本老舊程式碼都稱之為遺留程式碼。此名稱形容難以維護、難以測試以及難以閱讀。</p>\n</li>\n<li><p>我能在幾分鐘跑完所有單元測試嗎?</p>\n<p>如果你不能很快地執行完所有測試(在幾秒鐘內完成，比起幾分鐘才能完成要好得多)，你就不會經常執行它們。問題是，如果修改程式，你想盡早回饋確保自己沒弄壞什麼功能。當執行測試週期越長，你對系統未經測試的修改越多，出現問題時可能的原因點就越多。</p>\n<p>優秀的單元測試執行速度應該很快。</p>\n</li>\n<li><p>我能一鍵執行所有我寫過的單元測試嗎?</p>\n<p>如果不能，那意味你可能需要對執行測試機器進行一些設定，才能讓測試能正常執行，或是你的測試並非完全自動化。如果不能將單元測試自動化，你可能每次重複測試的時候，跳過這些沒被自動化的測試程式。</p>\n<p>優秀的測試無需進行額外手動的設定或處理，就能被自動執行。</p>\n</li>\n<li><p>我能在幾分鐘寫出一個基本單元測試嗎？</p>\n<p>單元測試其中一個特色，就是測試出每個問題細節，而不是關注於大問題。當你只關注較大的問題，測試的邏輯覆蓋率就會比較低，程式碼中很多核心邏輯不會被測試到，這樣就可能出現未曾可慮到的bug，一旦你已經發現適合測試你的物件模型的模式後，優秀的單元測試，應該要很容易，很快速被撰寫完。一個小警告:面對一個沒有被單元測試保護的物件模型，即便是有經驗的單元測試人員，也需要花上30分鐘或更長時間撰寫出第一個好的單元測試。</p>\n</li>\n</ul>\n<h4 id=\"1-4-什麼是優秀的單元測試\"><a href=\"#1-4-什麼是優秀的單元測試\" class=\"headerlink\" title=\"1.4 什麼是優秀的單元測試\"></a>1.4 什麼是優秀的單元測試</h4><p>一個單元測試是一段自動化程式碼，這段程式會呼叫被測試的工作單元，之後對這個單元的單一最終結得某些假設或期望進行驗證。單元測試幾乎都是靠使用單元測試框架進行撰寫。單元測試可靠、易讀、易維護。只要產品程式碼不發生變化，單元測試執行結果是穩定一致。</p>\n<p>作者說:前一版本只針對控制流程屬於單元的一部分，但作者現在不這麼認為。沒有邏輯判斷程式碼通常屬於工作單元的一部分。</p>\n<pre><code>控制程式碼:通常包含某種邏輯，無論是規模有多小。控制流程程式碼包含下面列舉:if語句、loop或switch或case語句。</code></pre>\n<p>參考資料: </p>\n<p>1.單元測試的藝術 第二版</p>\n"},{"title":"菜鳥工程師👨‍💻","date":"2020-11-10T15:50:50.000Z","type":"tags","_content":"\n菜鳥工程師👨‍💻\n=============\n\n##### 第一篇日記\n\n&nbsp;&nbsp;大學畢業後馬上擔任網頁後端工程師，在職中也有繼續就讀碩士班，不斷充實自己，雖說年資不久但也經歷過許多大小事情，希望藉此透過部落格來撰寫工程師歷程心得:D。","source":"_posts/feeling/202011121830.md","raw":"---\ntitle: 菜鳥工程師👨‍💻\ndate: 2020-11-10 23:50:50\ntype: \"tags\"\ntags: 心情日誌\ncategories: 心情日誌\n---\n\n菜鳥工程師👨‍💻\n=============\n\n##### 第一篇日記\n\n&nbsp;&nbsp;大學畢業後馬上擔任網頁後端工程師，在職中也有繼續就讀碩士班，不斷充實自己，雖說年資不久但也經歷過許多大小事情，希望藉此透過部落格來撰寫工程師歷程心得:D。","slug":"feeling/202011121830","published":1,"updated":"2022-03-16T13:16:23.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0tlcc6c000dfx7rgb8z717h","content":"<h1 id=\"菜鳥工程師👨‍💻\"><a href=\"#菜鳥工程師👨‍💻\" class=\"headerlink\" title=\"菜鳥工程師👨‍💻\"></a>菜鳥工程師👨‍💻</h1><h5 id=\"第一篇日記\"><a href=\"#第一篇日記\" class=\"headerlink\" title=\"第一篇日記\"></a>第一篇日記</h5><p>&nbsp;&nbsp;大學畢業後馬上擔任網頁後端工程師，在職中也有繼續就讀碩士班，不斷充實自己，雖說年資不久但也經歷過許多大小事情，希望藉此透過部落格來撰寫工程師歷程心得:D。</p>\n","site":{"data":{"styles":""}},"excerpt":"菜鳥工程師👨‍💻\n第一篇日記\n大學畢業後馬上擔任網頁後端工程師，在職中也有繼續就讀碩士班，不斷充實自己，雖說年資不久但也經歷過許多大小事情，希望藉此透過部落格來撰寫工程師歷程心得:D。","more":"<h1 id=\"菜鳥工程師👨‍💻\"><a href=\"#菜鳥工程師👨‍💻\" class=\"headerlink\" title=\"菜鳥工程師👨‍💻\"></a>菜鳥工程師👨‍💻</h1><h5 id=\"第一篇日記\"><a href=\"#第一篇日記\" class=\"headerlink\" title=\"第一篇日記\"></a>第一篇日記</h5><p>&nbsp;&nbsp;大學畢業後馬上擔任網頁後端工程師，在職中也有繼續就讀碩士班，不斷充實自己，雖說年資不久但也經歷過許多大小事情，希望藉此透過部落格來撰寫工程師歷程心得:D。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl0tlcc5y0002fx7r3862h0pq","category_id":"cl0tlcc650005fx7rfl319u0g","_id":"cl0tlcc6e000efx7rf3jq97jr"},{"post_id":"cl0tlcc630004fx7rfem46lmu","category_id":"cl0tlcc6b000afx7r54y5bre3","_id":"cl0tlcc6i000jfx7rac6cezrm"},{"post_id":"cl0tlcc680007fx7r3og41u1v","category_id":"cl0tlcc6b000afx7r54y5bre3","_id":"cl0tlcc6k000nfx7r2ch8b270"},{"post_id":"cl0tlcc690008fx7rhjmc4j7f","category_id":"cl0tlcc6b000afx7r54y5bre3","_id":"cl0tlcc6k000qfx7r0xf9am9r"},{"post_id":"cl0tlcc6a0009fx7rfd4r0mba","category_id":"cl0tlcc6j000mfx7r51gj9ip9","_id":"cl0tlcc6l000ufx7r4at95y4l"},{"post_id":"cl0tlcc6c000dfx7rgb8z717h","category_id":"cl0tlcc6k000rfx7r7ebo99gn","_id":"cl0tlcc6m000wfx7rg4be3l4r"}],"PostTag":[{"post_id":"cl0tlcc5y0002fx7r3862h0pq","tag_id":"cl0tlcc670006fx7rfgxcc6ma","_id":"cl0tlcc6c000cfx7r9hi8fq0v"},{"post_id":"cl0tlcc630004fx7rfem46lmu","tag_id":"cl0tlcc6b000bfx7rcrkfh2dx","_id":"cl0tlcc6h000hfx7rcg5t18vc"},{"post_id":"cl0tlcc680007fx7r3og41u1v","tag_id":"cl0tlcc6b000bfx7rcrkfh2dx","_id":"cl0tlcc6j000lfx7r5vxla6gh"},{"post_id":"cl0tlcc690008fx7rhjmc4j7f","tag_id":"cl0tlcc6b000bfx7rcrkfh2dx","_id":"cl0tlcc6k000pfx7r1n4uguz2"},{"post_id":"cl0tlcc6a0009fx7rfd4r0mba","tag_id":"cl0tlcc6k000ofx7r5gt73ula","_id":"cl0tlcc6l000tfx7r3e1y6g23"},{"post_id":"cl0tlcc6c000dfx7rgb8z717h","tag_id":"cl0tlcc6l000sfx7r0pq1f72i","_id":"cl0tlcc6m000vfx7r2lsc74ou"}],"Tag":[{"name":"php","_id":"cl0tlcc670006fx7rfgxcc6ma"},{"name":"資料庫","_id":"cl0tlcc6b000bfx7rcrkfh2dx"},{"name":"單元測試","_id":"cl0tlcc6k000ofx7r5gt73ula"},{"name":"心情日誌","_id":"cl0tlcc6l000sfx7r0pq1f72i"}]}}